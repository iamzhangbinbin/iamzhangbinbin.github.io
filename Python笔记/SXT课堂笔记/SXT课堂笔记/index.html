
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="张彬彬的个人技术博客">
      
      
        <meta name="author" content="张彬彬">
      
      
        <link rel="canonical" href="https://iamzhangbinbin.github.io/Python%E7%AC%94%E8%AE%B0/SXT%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/SXT%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/">
      
      
        <link rel="prev" href="../../">
      
      
        <link rel="next" href="../../Python%20GUI%20%E7%9A%84%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95/">
      
      
      <link rel="icon" href="../../../img/favicon.ico">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.14">
    
    
      
        <title>SXT课堂笔记 - 张彬彬的杂货铺</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.342714a4.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="light-blue" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#sxt" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="张彬彬的杂货铺" class="md-header__button md-logo" aria-label="张彬彬的杂货铺" data-md-component="logo">
      
  <img src="../../../img/zahuopu.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            张彬彬的杂货铺
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              SXT课堂笔记
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="light-blue" data-md-color-accent="indigo"  aria-label="切换至夜间模式"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="切换至夜间模式" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3zm3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95zm-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="indigo"  aria-label="切换至日间模式"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="切换至日间模式" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5s-1.65.15-2.39.42zM3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29zm.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14zM20.65 7l-1.77 3.79a7.02 7.02 0 0 0-2.38-4.15zm-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29zM12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
          <a href="javascript:void(0)" class="md-search__icon md-icon" title="分享" aria-label="分享" data-clipboard data-clipboard-text="" data-md-component="search-share" tabindex="-1">
            
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91s2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08"/></svg>
          </a>
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/iamzhangbinbin/iamzhangbinbin.github.io" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    I'mZhangBinbin
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../MCU%E5%BC%80%E5%8F%91%E6%94%AF%E6%8C%81/" class="md-tabs__link">
          
  
  
    
  
  MCU开发支持

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../MM32%20Guide/" class="md-tabs__link">
          
  
  
    
  
  MM32 Guide

        </a>
      </li>
    
  

      
        
  
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../../" class="md-tabs__link">
          
  
  
    
  
  Python笔记

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%A7%BB%E6%A4%8D/" class="md-tabs__link">
          
  
  
    
  
  开源软件移植

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../%E6%A0%87%E5%87%86%E4%B8%8E%E8%AE%A4%E8%AF%81/" class="md-tabs__link">
          
  
  
    
  
  标准与认证

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../USB%E5%85%A5%E9%97%A8/" class="md-tabs__link">
          
  
  
    
  
  USB入门

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../CAN%E5%85%A5%E9%97%A8/" class="md-tabs__link">
          
  
  
    
  
  CAN入门

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../ENET%E5%85%A5%E9%97%A8/" class="md-tabs__link">
          
  
  
    
  
  ENET入门

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../blog/" class="md-tabs__link">
          
  
  
    
  
  博客

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../.." class="md-tabs__link">
          
  
  
    
  
  About

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


  

<nav class="md-nav md-nav--primary md-nav--lifted md-nav--integrated" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="张彬彬的杂货铺" class="md-nav__button md-logo" aria-label="张彬彬的杂货铺" data-md-component="logo">
      
  <img src="../../../img/zahuopu.png" alt="logo">

    </a>
    张彬彬的杂货铺
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/iamzhangbinbin/iamzhangbinbin.github.io" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    I'mZhangBinbin
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
    
      
      
        
      
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
  
    <a href="../../../MCU%E5%BC%80%E5%8F%91%E6%94%AF%E6%8C%81/" class="md-nav__link">
      
  
  
  <span class="md-ellipsis">
    MCU开发支持
    
  </span>
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
    
    
    
      
      
        
      
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
  
    <a href="../../../MM32%20Guide/" class="md-nav__link">
      
  
  
  <span class="md-ellipsis">
    MM32 Guide
    
  </span>
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
    
      
        
        
      
      
        
      
    
    
      
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" checked>
        
          
          <div class="md-nav__link md-nav__container">
            <a href="../../" class="md-nav__link ">
              
  
  
  <span class="md-ellipsis">
    Python笔记
    
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_3" id="__nav_3_label" tabindex="">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Python笔记
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    SXT课堂笔记
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    SXT课堂笔记
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#python" class="md-nav__link">
    <span class="md-ellipsis">
      Python入门
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Python入门">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#python_1" class="md-nav__link">
    <span class="md-ellipsis">
      Python介绍
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Python介绍">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      简介
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      特点
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      应用范围
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#python_2" class="md-nav__link">
    <span class="md-ellipsis">
      Python 解释器
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#python_3" class="md-nav__link">
    <span class="md-ellipsis">
      Python开发入门
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Python开发入门">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#python_4" class="md-nav__link">
    <span class="md-ellipsis">
      Python 下载安装和配置
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#python_5" class="md-nav__link">
    <span class="md-ellipsis">
      Python 开发环境
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#shell" class="md-nav__link">
    <span class="md-ellipsis">
      交互模式(脚本 shell 模式)
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#idle" class="md-nav__link">
    <span class="md-ellipsis">
      IDLE 开发环境使用入门
    </span>
  </a>
  
    <nav class="md-nav" aria-label="IDLE 开发环境使用入门">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#idle_1" class="md-nav__link">
    <span class="md-ellipsis">
      IDLE 介绍
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#idle_2" class="md-nav__link">
    <span class="md-ellipsis">
      IDLE 实操
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#idle_3" class="md-nav__link">
    <span class="md-ellipsis">
      IDLE 常用快捷键
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    <span class="md-ellipsis">
      程序基本格式
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    <span class="md-ellipsis">
      编程基本概念
    </span>
  </a>
  
    <nav class="md-nav" aria-label="编程基本概念">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#python_6" class="md-nav__link">
    <span class="md-ellipsis">
      Python 程序的构成
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Python 程序的构成">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#python_7" class="md-nav__link">
    <span class="md-ellipsis">
      Python 文件的创建和执行
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    <span class="md-ellipsis">
      代码的组织和缩进
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    <span class="md-ellipsis">
      使用注释#
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    <span class="md-ellipsis">
      使用\行连接符
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    <span class="md-ellipsis">
      对象
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    <span class="md-ellipsis">
      引用
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    <span class="md-ellipsis">
      标识符
    </span>
  </a>
  
    <nav class="md-nav" aria-label="标识符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    <span class="md-ellipsis">
      基本用法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#python_8" class="md-nav__link">
    <span class="md-ellipsis">
      Python 标识符命名规则
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    <span class="md-ellipsis">
      变量和简单赋值语句
    </span>
  </a>
  
    <nav class="md-nav" aria-label="变量和简单赋值语句">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    <span class="md-ellipsis">
      变量的声明和赋值
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    <span class="md-ellipsis">
      删除变量和垃圾回收机制
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    <span class="md-ellipsis">
      链式赋值
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    <span class="md-ellipsis">
      系列解包赋值
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    <span class="md-ellipsis">
      常量
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    <span class="md-ellipsis">
      基本内置数据类型和运算符
    </span>
  </a>
  
    <nav class="md-nav" aria-label="基本内置数据类型和运算符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    <span class="md-ellipsis">
      数字和基本运算符
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    <span class="md-ellipsis">
      整数
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    <span class="md-ellipsis">
      浮点数
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    <span class="md-ellipsis">
      类型转换和四舍五入
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    <span class="md-ellipsis">
      增强型赋值运算符
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    <span class="md-ellipsis">
      时间的表示
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    <span class="md-ellipsis">
      布尔值
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    <span class="md-ellipsis">
      比较运算符
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_28" class="md-nav__link">
    <span class="md-ellipsis">
      逻辑运算符
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_29" class="md-nav__link">
    <span class="md-ellipsis">
      同一运算符
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_30" class="md-nav__link">
    <span class="md-ellipsis">
      整数缓存问题
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_31" class="md-nav__link">
    <span class="md-ellipsis">
      基本运算符
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_32" class="md-nav__link">
    <span class="md-ellipsis">
      复合赋值运算符
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_33" class="md-nav__link">
    <span class="md-ellipsis">
      运算符优先级问题
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_34" class="md-nav__link">
    <span class="md-ellipsis">
      字符串
    </span>
  </a>
  
    <nav class="md-nav" aria-label="字符串">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_35" class="md-nav__link">
    <span class="md-ellipsis">
      字符串基本特点
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_36" class="md-nav__link">
    <span class="md-ellipsis">
      字符串的编码
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_37" class="md-nav__link">
    <span class="md-ellipsis">
      引号创建字符串
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#len" class="md-nav__link">
    <span class="md-ellipsis">
      空字符串和 len()函数
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_38" class="md-nav__link">
    <span class="md-ellipsis">
      转义字符
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_39" class="md-nav__link">
    <span class="md-ellipsis">
      字符串拼接
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_40" class="md-nav__link">
    <span class="md-ellipsis">
      字符串复制
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_41" class="md-nav__link">
    <span class="md-ellipsis">
      不换行打印
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_42" class="md-nav__link">
    <span class="md-ellipsis">
      从控制台读取字符串
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#str" class="md-nav__link">
    <span class="md-ellipsis">
      str()实现数字转型字符串
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_43" class="md-nav__link">
    <span class="md-ellipsis">
      使用[]提取字符
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#replace" class="md-nav__link">
    <span class="md-ellipsis">
      replace()实现字符串替换
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#slice" class="md-nav__link">
    <span class="md-ellipsis">
      字符串切片 slice 操作
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#split-join" class="md-nav__link">
    <span class="md-ellipsis">
      split()分割和 join()合并
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_44" class="md-nav__link">
    <span class="md-ellipsis">
      字符串驻留机制和字符串比较
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_45" class="md-nav__link">
    <span class="md-ellipsis">
      字符串比较和同一性
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_46" class="md-nav__link">
    <span class="md-ellipsis">
      成员操作符
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_47" class="md-nav__link">
    <span class="md-ellipsis">
      字符串常用方法汇总
    </span>
  </a>
  
    <nav class="md-nav" aria-label="字符串常用方法汇总">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_48" class="md-nav__link">
    <span class="md-ellipsis">
      常用查找方法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_49" class="md-nav__link">
    <span class="md-ellipsis">
      去除首尾信息
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_50" class="md-nav__link">
    <span class="md-ellipsis">
      大小写转换
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_51" class="md-nav__link">
    <span class="md-ellipsis">
      格式排版
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_52" class="md-nav__link">
    <span class="md-ellipsis">
      其他方法
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_53" class="md-nav__link">
    <span class="md-ellipsis">
      字符串的格式化
    </span>
  </a>
  
    <nav class="md-nav" aria-label="字符串的格式化">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#format" class="md-nav__link">
    <span class="md-ellipsis">
      format()基本用法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_54" class="md-nav__link">
    <span class="md-ellipsis">
      填充与对齐
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_55" class="md-nav__link">
    <span class="md-ellipsis">
      数字格式化
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_56" class="md-nav__link">
    <span class="md-ellipsis">
      可变字符串
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_57" class="md-nav__link">
    <span class="md-ellipsis">
      序列
    </span>
  </a>
  
    <nav class="md-nav" aria-label="序列">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_58" class="md-nav__link">
    <span class="md-ellipsis">
      列表简介
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_59" class="md-nav__link">
    <span class="md-ellipsis">
      列表的创建
    </span>
  </a>
  
    <nav class="md-nav" aria-label="列表的创建">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_60" class="md-nav__link">
    <span class="md-ellipsis">
      基本语法[]创建
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#list" class="md-nav__link">
    <span class="md-ellipsis">
      list()创建
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#range" class="md-nav__link">
    <span class="md-ellipsis">
      range()创建整数列表
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_61" class="md-nav__link">
    <span class="md-ellipsis">
      推导式生成列表
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_62" class="md-nav__link">
    <span class="md-ellipsis">
      列表元素的增加
    </span>
  </a>
  
    <nav class="md-nav" aria-label="列表元素的增加">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#append" class="md-nav__link">
    <span class="md-ellipsis">
      append()方法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_63" class="md-nav__link">
    <span class="md-ellipsis">
      +运算符操作
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#extend" class="md-nav__link">
    <span class="md-ellipsis">
      extend()方法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#insert" class="md-nav__link">
    <span class="md-ellipsis">
      insert()插入元素
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_64" class="md-nav__link">
    <span class="md-ellipsis">
      乘法扩展
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_65" class="md-nav__link">
    <span class="md-ellipsis">
      列表元素的删除
    </span>
  </a>
  
    <nav class="md-nav" aria-label="列表元素的删除">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#del" class="md-nav__link">
    <span class="md-ellipsis">
      del 删除
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pop" class="md-nav__link">
    <span class="md-ellipsis">
      pop()方法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#remove" class="md-nav__link">
    <span class="md-ellipsis">
      remove()方法
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_66" class="md-nav__link">
    <span class="md-ellipsis">
      列表元素访问和计数
    </span>
  </a>
  
    <nav class="md-nav" aria-label="列表元素访问和计数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_67" class="md-nav__link">
    <span class="md-ellipsis">
      通过索引直接访问元素
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#index" class="md-nav__link">
    <span class="md-ellipsis">
      index()获得指定元素在列表中首次出现的索引
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#count" class="md-nav__link">
    <span class="md-ellipsis">
      count()获得指定元素在列表中出现的次数
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#len_1" class="md-nav__link">
    <span class="md-ellipsis">
      len()返回列表长度
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_68" class="md-nav__link">
    <span class="md-ellipsis">
      成员资格判断
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_69" class="md-nav__link">
    <span class="md-ellipsis">
      切片操作
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_70" class="md-nav__link">
    <span class="md-ellipsis">
      列表的遍历
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_71" class="md-nav__link">
    <span class="md-ellipsis">
      复制列表所有的元素到新列表对象
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_72" class="md-nav__link">
    <span class="md-ellipsis">
      列表排序
    </span>
  </a>
  
    <nav class="md-nav" aria-label="列表排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_73" class="md-nav__link">
    <span class="md-ellipsis">
      修改原列表，不建新列表的排序
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_74" class="md-nav__link">
    <span class="md-ellipsis">
      建新列表的排序
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#reversed" class="md-nav__link">
    <span class="md-ellipsis">
      reversed()返回迭代器
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_75" class="md-nav__link">
    <span class="md-ellipsis">
      列表相关的其他内置函数汇总
    </span>
  </a>
  
    <nav class="md-nav" aria-label="列表相关的其他内置函数汇总">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#max-min" class="md-nav__link">
    <span class="md-ellipsis">
      max 和 min
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sum" class="md-nav__link">
    <span class="md-ellipsis">
      sum
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_76" class="md-nav__link">
    <span class="md-ellipsis">
      多维列表
    </span>
  </a>
  
    <nav class="md-nav" aria-label="多维列表">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_77" class="md-nav__link">
    <span class="md-ellipsis">
      二维列表
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tuple" class="md-nav__link">
    <span class="md-ellipsis">
      元组 tuple
    </span>
  </a>
  
    <nav class="md-nav" aria-label="元组 tuple">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_78" class="md-nav__link">
    <span class="md-ellipsis">
      元组的创建
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_79" class="md-nav__link">
    <span class="md-ellipsis">
      元组的元素访问和计数
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zip" class="md-nav__link">
    <span class="md-ellipsis">
      zip
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_80" class="md-nav__link">
    <span class="md-ellipsis">
      生成器推导式创建元组
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_81" class="md-nav__link">
    <span class="md-ellipsis">
      元组总结
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_82" class="md-nav__link">
    <span class="md-ellipsis">
      字典介绍
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_83" class="md-nav__link">
    <span class="md-ellipsis">
      字典的创建
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_84" class="md-nav__link">
    <span class="md-ellipsis">
      字典元素的访问
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_85" class="md-nav__link">
    <span class="md-ellipsis">
      字典元素添加、修改、删除
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_86" class="md-nav__link">
    <span class="md-ellipsis">
      序列解包
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_87" class="md-nav__link">
    <span class="md-ellipsis">
      表格数据使用字典和列表存储，并实现访问
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_88" class="md-nav__link">
    <span class="md-ellipsis">
      控制语句
    </span>
  </a>
  
    <nav class="md-nav" aria-label="控制语句">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_89" class="md-nav__link">
    <span class="md-ellipsis">
      选择结构
    </span>
  </a>
  
    <nav class="md-nav" aria-label="选择结构">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_90" class="md-nav__link">
    <span class="md-ellipsis">
      单分支选择结构
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_91" class="md-nav__link">
    <span class="md-ellipsis">
      条件表达式详解
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_92" class="md-nav__link">
    <span class="md-ellipsis">
      双分支选择结构
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_93" class="md-nav__link">
    <span class="md-ellipsis">
      三元条件运算符
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_94" class="md-nav__link">
    <span class="md-ellipsis">
      多分支选择结构
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_95" class="md-nav__link">
    <span class="md-ellipsis">
      选择结构嵌套
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_96" class="md-nav__link">
    <span class="md-ellipsis">
      循环结构
    </span>
  </a>
  
    <nav class="md-nav" aria-label="循环结构">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#while" class="md-nav__link">
    <span class="md-ellipsis">
      while 循环
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#for" class="md-nav__link">
    <span class="md-ellipsis">
      for 循环和可迭代对象遍历
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_97" class="md-nav__link">
    <span class="md-ellipsis">
      可迭代对象
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#range_1" class="md-nav__link">
    <span class="md-ellipsis">
      range 对象
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_98" class="md-nav__link">
    <span class="md-ellipsis">
      嵌套循环和综合练习
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#break" class="md-nav__link">
    <span class="md-ellipsis">
      break 语句
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#continue" class="md-nav__link">
    <span class="md-ellipsis">
      continue 语句
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#else" class="md-nav__link">
    <span class="md-ellipsis">
      else 语句
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_99" class="md-nav__link">
    <span class="md-ellipsis">
      循环代码优化
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_100" class="md-nav__link">
    <span class="md-ellipsis">
      其他优化手段
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zip_1" class="md-nav__link">
    <span class="md-ellipsis">
      使用 zip()并行迭代
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_101" class="md-nav__link">
    <span class="md-ellipsis">
      推导式创建序列
    </span>
  </a>
  
    <nav class="md-nav" aria-label="推导式创建序列">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_102" class="md-nav__link">
    <span class="md-ellipsis">
      列表推导式
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_103" class="md-nav__link">
    <span class="md-ellipsis">
      字典推导式
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_104" class="md-nav__link">
    <span class="md-ellipsis">
      集合推导式
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_105" class="md-nav__link">
    <span class="md-ellipsis">
      生成器推导式（生成元组）
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_106" class="md-nav__link">
    <span class="md-ellipsis">
      函数用法和底层分析
    </span>
  </a>
  
    <nav class="md-nav" aria-label="函数用法和底层分析">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_107" class="md-nav__link">
    <span class="md-ellipsis">
      函数简介
    </span>
  </a>
  
    <nav class="md-nav" aria-label="函数简介">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_108" class="md-nav__link">
    <span class="md-ellipsis">
      函数的基本概念
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#python_9" class="md-nav__link">
    <span class="md-ellipsis">
      Python 函数的分类
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_109" class="md-nav__link">
    <span class="md-ellipsis">
      函数的定义和调用
    </span>
  </a>
  
    <nav class="md-nav" aria-label="函数的定义和调用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_110" class="md-nav__link">
    <span class="md-ellipsis">
      核心要点
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_111" class="md-nav__link">
    <span class="md-ellipsis">
      形参和实参
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_112" class="md-nav__link">
    <span class="md-ellipsis">
      文档字符串(函数的注释)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_113" class="md-nav__link">
    <span class="md-ellipsis">
      返回值
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_114" class="md-nav__link">
    <span class="md-ellipsis">
      函数也是对象，内存底层分析
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_115" class="md-nav__link">
    <span class="md-ellipsis">
      变量的作用域
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_116" class="md-nav__link">
    <span class="md-ellipsis">
      局部变量和全局变量效率测试
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_117" class="md-nav__link">
    <span class="md-ellipsis">
      参数的传递
    </span>
  </a>
  
    <nav class="md-nav" aria-label="参数的传递">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_118" class="md-nav__link">
    <span class="md-ellipsis">
      传递可变对象的引用
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_119" class="md-nav__link">
    <span class="md-ellipsis">
      传递不可变对象的引用
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_120" class="md-nav__link">
    <span class="md-ellipsis">
      浅拷贝和深拷贝
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_121" class="md-nav__link">
    <span class="md-ellipsis">
      传递不可变对象包含的子对象是可变的情况
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_122" class="md-nav__link">
    <span class="md-ellipsis">
      参数的几种类型
    </span>
  </a>
  
    <nav class="md-nav" aria-label="参数的几种类型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_123" class="md-nav__link">
    <span class="md-ellipsis">
      位置参数
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_124" class="md-nav__link">
    <span class="md-ellipsis">
      默认值参数
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_125" class="md-nav__link">
    <span class="md-ellipsis">
      命名参数
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_126" class="md-nav__link">
    <span class="md-ellipsis">
      可变参数
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_127" class="md-nav__link">
    <span class="md-ellipsis">
      强制命名参数
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lambda" class="md-nav__link">
    <span class="md-ellipsis">
      lambda 表达式和匿名函数
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eval" class="md-nav__link">
    <span class="md-ellipsis">
      eval()函数
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_128" class="md-nav__link">
    <span class="md-ellipsis">
      递归函数
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nonlocal" class="md-nav__link">
    <span class="md-ellipsis">
      nonlocal 关键字
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#legb" class="md-nav__link">
    <span class="md-ellipsis">
      LEGB 规则
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_129" class="md-nav__link">
    <span class="md-ellipsis">
      面向对象编程
    </span>
  </a>
  
    <nav class="md-nav" aria-label="面向对象编程">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_130" class="md-nav__link">
    <span class="md-ellipsis">
      面向对象和面向过程区别
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_131" class="md-nav__link">
    <span class="md-ellipsis">
      对象的进化
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_132" class="md-nav__link">
    <span class="md-ellipsis">
      类的定义
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#__init____new__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__构造方法和__new__方法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_133" class="md-nav__link">
    <span class="md-ellipsis">
      实例属性和实例方法
    </span>
  </a>
  
    <nav class="md-nav" aria-label="实例属性和实例方法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_134" class="md-nav__link">
    <span class="md-ellipsis">
      实例属性
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_135" class="md-nav__link">
    <span class="md-ellipsis">
      实例方法
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_136" class="md-nav__link">
    <span class="md-ellipsis">
      类对象、类属性、类方法、静态方法
    </span>
  </a>
  
    <nav class="md-nav" aria-label="类对象、类属性、类方法、静态方法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_137" class="md-nav__link">
    <span class="md-ellipsis">
      类对象
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_138" class="md-nav__link">
    <span class="md-ellipsis">
      类属性
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_139" class="md-nav__link">
    <span class="md-ellipsis">
      类方法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_140" class="md-nav__link">
    <span class="md-ellipsis">
      静态方法
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_141" class="md-nav__link">
    <span class="md-ellipsis">
      内存分析实例对象和类对象创建过程
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#__del__" class="md-nav__link">
    <span class="md-ellipsis">
      __del__方法(析构函数)和垃圾回收机制
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#__call__" class="md-nav__link">
    <span class="md-ellipsis">
      __call__方法和可调用对象
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_142" class="md-nav__link">
    <span class="md-ellipsis">
      方法没有重载
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_143" class="md-nav__link">
    <span class="md-ellipsis">
      方法的动态性
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_144" class="md-nav__link">
    <span class="md-ellipsis">
      私有属性和私有方法(实现封装)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#property" class="md-nav__link">
    <span class="md-ellipsis">
      @property 装饰器
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_145" class="md-nav__link">
    <span class="md-ellipsis">
      属性和方法命名总结
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_146" class="md-nav__link">
    <span class="md-ellipsis">
      类编码风格
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_147" class="md-nav__link">
    <span class="md-ellipsis">
      面向对象三大特征介绍
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_148" class="md-nav__link">
    <span class="md-ellipsis">
      继承
    </span>
  </a>
  
    <nav class="md-nav" aria-label="继承">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_149" class="md-nav__link">
    <span class="md-ellipsis">
      语法格式
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_150" class="md-nav__link">
    <span class="md-ellipsis">
      类成员的继承和重写
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_151" class="md-nav__link">
    <span class="md-ellipsis">
      查看类的继承层次结构
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#object" class="md-nav__link">
    <span class="md-ellipsis">
      object 根类
    </span>
  </a>
  
    <nav class="md-nav" aria-label="object 根类">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dir" class="md-nav__link">
    <span class="md-ellipsis">
      dir()查看对象属性
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#__str__" class="md-nav__link">
    <span class="md-ellipsis">
      重写__str__()方法
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_152" class="md-nav__link">
    <span class="md-ellipsis">
      多重继承
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mro" class="md-nav__link">
    <span class="md-ellipsis">
      MRO()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#super" class="md-nav__link">
    <span class="md-ellipsis">
      super()获得父类定义
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_153" class="md-nav__link">
    <span class="md-ellipsis">
      多态
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_154" class="md-nav__link">
    <span class="md-ellipsis">
      特殊方法和运算符重载
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_155" class="md-nav__link">
    <span class="md-ellipsis">
      特殊属性
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_156" class="md-nav__link">
    <span class="md-ellipsis">
      对象的浅拷贝和深拷贝
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_157" class="md-nav__link">
    <span class="md-ellipsis">
      组合
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_" class="md-nav__link">
    <span class="md-ellipsis">
      设计模式_工厂模式
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#__1" class="md-nav__link">
    <span class="md-ellipsis">
      设计模式_单例模式
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Python%20GUI%20%E7%9A%84%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Python GUI 的几种写法
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
    
    
    
      
      
        
      
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
  
    <a href="../../../%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%A7%BB%E6%A4%8D/" class="md-nav__link">
      
  
  
  <span class="md-ellipsis">
    开源软件移植
    
  </span>
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
    
      
      
        
      
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
  
    <a href="../../../%E6%A0%87%E5%87%86%E4%B8%8E%E8%AE%A4%E8%AF%81/" class="md-nav__link">
      
  
  
  <span class="md-ellipsis">
    标准与认证
    
  </span>
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
    
      
      
        
      
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
  
    <a href="../../../USB%E5%85%A5%E9%97%A8/" class="md-nav__link">
      
  
  
  <span class="md-ellipsis">
    USB入门
    
  </span>
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
    
      
      
        
      
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
  
    <a href="../../../CAN%E5%85%A5%E9%97%A8/" class="md-nav__link">
      
  
  
  <span class="md-ellipsis">
    CAN入门
    
  </span>
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
    
    
    
      
      
        
      
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
  
    <a href="../../../ENET%E5%85%A5%E9%97%A8/" class="md-nav__link">
      
  
  
  <span class="md-ellipsis">
    ENET入门
    
  </span>
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
    
      
      
        
      
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
  
    <a href="../../../blog/" class="md-nav__link">
      
  
  
  <span class="md-ellipsis">
    博客
    
  </span>
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
    
      
      
        
      
    
    
      
        
        
      
    
    <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
      
        
  
  
  
    <a href="../../.." class="md-nav__link">
      
  
  
  <span class="md-ellipsis">
    About
    
  </span>
  

      
        <span class="md-nav__icon md-icon"></span>
      
    </a>
  

      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  
  


<h1 id="sxt">SXT课堂笔记<a class="headerlink" href="#sxt" title="Permanent link">&para;</a></h1>
<h2 id="python">Python入门<a class="headerlink" href="#python" title="Permanent link">&para;</a></h2>
<h3 id="python_1">Python介绍<a class="headerlink" href="#python_1" title="Permanent link">&para;</a></h3>
<h4 id="_1">简介<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h4>
<p>Python 是一种解释型、面向对象的语言。由吉多·范·罗苏姆（Guido van Rossum）于1989 年发明，1991 年正式公布。官网：<a href="https://www.python.org/">https://www.python.org/</a><br />
<img alt="alt text" src="../image.png" />
Python 单词是“大蟒蛇”的意思。但是龟叔不是喜欢蟒蛇才起这个名字，而是正在追剧：英国电视喜剧片《蒙提·派森的飞行马戏团》(Monty Python and the Flying Circus)。<br />
<img alt="alt text" src="../image-1.png" />  </p>
<h4 id="_2">特点<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h4>
<ol>
<li>可读性强<br />
可读性远比听上去重要的多得多。一个程序会被反复的修改，可读性强意味着让你可以在更短时间内学习和记忆，直接提高生产率。  </li>
<li>简洁，简洁，简洁<br />
研究证明，程序员每天可编写的有效代码数是有限的。完成同样功能只用一半的代码，其实就是提高了一倍的生产率。<br />
Python 是由 C 语言开发，但是不再有 C 语言中指针等复杂数据类型，Python 的简洁性让开发难度和代码幅度大幅降低，开发任务大大简化。程序员再也不需要关注复杂的语法，而是关注任务本身。  </li>
<li>面向对象  </li>
<li>免费和开源  </li>
<li>可移植性和跨平台<br />
Python 会被编译成与操作系统相关的二进制代码，然后再解释执行。这种方式和java 类似，大大提高了执行速度，也实现了跨平台。</li>
<li>丰富的库（丰富的标准库， 多种多样的扩展库）  </li>
<li>可扩展性。 可嵌入到 C 和 C++语言。 胶水式语言。</li>
</ol>
<h4 id="_3">应用范围<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h4>
<ol>
<li>科学计算</li>
<li>人工智能</li>
<li>WEB 服务端和大型网站后端。<br />
YouTube、gmail 等应用基于 python 开发。</li>
<li>GUI 开发（图形用户界面开发）</li>
<li>游戏开发</li>
<li>移动设备</li>
<li>嵌入式设备</li>
<li>系统运维</li>
<li>大数据</li>
<li>云计算</li>
</ol>
<h4 id="python_2">Python 解释器<a class="headerlink" href="#python_2" title="Permanent link">&para;</a></h4>
<p>Python 程序的执行依赖于 Python 解释器。常用的 Python 解释器有：  </p>
<ol>
<li>
<p>CPython <br />
使用 c 语言实现的解释器，最常用的解释器。通常说的解释器指的就是它。 </p>
</li>
<li>
<p>Jython<br />
使用 java 语言实现的解释器。Jython 可以直接调用 java 类库，适合在 java 平台上开发  </p>
</li>
<li>
<p>IronPython<br />
.NET 平台上使用的解释器。可直接调用.NET 平台的类，适合.NET 平台上开发  </p>
</li>
<li>
<p>PyPy<br />
使用 Python 语言实现的解释器</p>
</li>
</ol>
<h3 id="python_3">Python开发入门<a class="headerlink" href="#python_3" title="Permanent link">&para;</a></h3>
<h4 id="python_4">Python 下载安装和配置<a class="headerlink" href="#python_4" title="Permanent link">&para;</a></h4>
<ol>
<li>进入官网</li>
<li>下载</li>
<li>安装（和安装一般软件区别不大）</li>
<li>环境变量问题
勾选：“Add Python to environment variable”。 这样就会将 Python 添加到环境
变量 Path 中，我们可以在 windows 的命令行模式下运行 Python 解释器。 <br />
<img alt="alt text" src="../image-2.png" /></li>
</ol>
<h4 id="python_5">Python 开发环境<a class="headerlink" href="#python_5" title="Permanent link">&para;</a></h4>
<p>开发环境，英文是 IDE（Integrated Development Environment 集成开发环境）。<br />
不要纠结于使用哪个开发环境。开发环境本质上就是对 Python 解释器 python.exe 的封装，核心都一样。可以说：“开发环境 IDE，只是解释器的一个外挂而已”，只是为了让程序员更加方便编程，减少出错率，尤其是拼写错误。<br />
常用的开发环境如下：  </p>
<ol>
<li>IDLE</li>
<li>Pycharm</li>
<li>wingIDE</li>
<li>Eclipse</li>
<li>IPython</li>
</ol>
<h4 id="shell">交互模式(脚本 shell 模式)<a class="headerlink" href="#shell" title="Permanent link">&para;</a></h4>
<ol>
<li>进入命令行窗口，输入：python
<img alt="alt text" src="../image-3.png" />  </li>
<li>“&gt;&gt;&gt;"即为“提示符”</li>
<li>关闭交互窗口： 
(1) Ctrl+Z 和回车
(2) 输入 quit()命令
(3) 直接关闭命令行窗口</li>
<li>中断程序执行：ctrl+C<br />
交互模式工作原理和 Python 处理文件的方式一样。除了一点：当你输入一些值时，交互模式会自动打印输出。Py 文件中则必须使用 print 语句。  </li>
</ol>
<h3 id="idle">IDLE 开发环境使用入门<a class="headerlink" href="#idle" title="Permanent link">&para;</a></h3>
<h4 id="idle_1">IDLE 介绍<a class="headerlink" href="#idle_1" title="Permanent link">&para;</a></h4>
<ol>
<li>IDLE 是 Python 的官方标准开发环境，Python 安装完后同时就安装了 IDLE。  </li>
<li>IDLE 已经具备了 Python 开发几乎所有功能（语法智能提示、不同颜色显示不同类型等等），也不需要其他配置，非常适合初学者使用。  </li>
<li>IDLE 是 Python 标准发行版内置的一个简单小巧的 IDE，包括了交互式命令行、编辑器、调试器等基本组件，足以应付大多数简单应用。 </li>
<li>IDLE 是用纯 Python 基于 Tkinter 编写，最初的作者正是 Python 之父 Guido van Rossum。</li>
</ol>
<h4 id="idle_2">IDLE 实操<a class="headerlink" href="#idle_2" title="Permanent link">&para;</a></h4>
<ol>
<li>交互模式<br />
启动 IDLE，默认就是进入交互模式。  </li>
<li>编写和执行 Python 源文件  </li>
</ol>
<h4 id="idle_3">IDLE 常用快捷键<a class="headerlink" href="#idle_3" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Alt+N Alt+P</td>
<td>查看历史命令上一条、下一条</td>
</tr>
<tr>
<td>Ctrl+F6</td>
<td>重启 shell，以前定义的变量全部失效</td>
</tr>
<tr>
<td>F1</td>
<td>打开帮助文档</td>
</tr>
<tr>
<td>Alt+/</td>
<td>自动补全前面曾经出现过的单词</td>
</tr>
<tr>
<td>Ctrl + [ Ctrl + ]</td>
<td>缩进代码和取消缩进</td>
</tr>
<tr>
<td>Alt+M</td>
<td>打开模块代码，先选中模块，然后按下此快捷键，会帮你打开改模块的 py 源码供浏览</td>
</tr>
<tr>
<td>Alt+C</td>
<td>打开类浏览器，方便在源码文件中的各个方法体之间切换</td>
</tr>
<tr>
<td>F5</td>
<td>运行程序</td>
</tr>
</tbody>
</table>
<h3 id="_4">程序基本格式<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h3>
<ol>
<li>恰当的空格，缩进问题<br />
(1) 逻辑行首的空白（空格和制表符）用来决定逻辑行的缩进层次，从而用来决定语句的分组。<br />
(2) 语句从新行的第一列开始。<br />
(3) 缩进风格统一：  <ul>
<li>每个缩进层次使用 单个制表符 或四个空格（IDE 会自动将制表符设置成 4 个空格）  </li>
<li>Python 用缩进而不是{}表示程序块</li>
</ul>
</li>
<li>Python 区分大小写</li>
<li>注释 <br />
(1) 行注释<br />
每行注释前加#号。当解释器看到#，则忽略这一行#后面的内容<br />
(2) 段注释<br />
使用三个连续单引号（'''）。当解释看到'''，则会扫描到下一个'''，然后忽略他们之间的内容。  </li>
</ol>
<h2 id="_5">编程基本概念<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h2>
<h3 id="python_6">Python 程序的构成<a class="headerlink" href="#python_6" title="Permanent link">&para;</a></h3>
<p><img alt="alt text" src="../image-4.png" /></p>
<ol>
<li>Python 程序由模块组成。一个模块对应 python 源文件，一般后缀名是：.py。  </li>
<li>模块由语句组成。运行 Python 程序时，按照模块中语句的顺序依次执行。  </li>
<li>语句是 Python 程序的构造单元，用于创建对象、变量赋值、调用函数、控制语句等。 </li>
</ol>
<h4 id="python_7">Python 文件的创建和执行<a class="headerlink" href="#python_7" title="Permanent link">&para;</a></h4>
<p>前面使用的交互式环境，每次只能执行一条语句；为了编写多条语句实现复杂的逻辑，本章开始我们通过创建 Python 文件，并执行该文件。<br />
在 IDLE 环境中，我们可以通过 File&rarr;new 创建 Python 文件，并可以编辑该文件内容。我们也可以通过 File&rarr;save/save as 保存文件。一般保存成扩展名为 py 的文件。<br />
需要执行编辑好的文件，可以用快捷键 F5 或者点击 Run&rarr;Run module。  </p>
<h4 id="_6">代码的组织和缩进<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h4>
<p>很多编程语言通过字符(例如：花括号{})、关键字(例如：begain/end)来划分代码块。 同时，在配合代码的缩进增加可读性。“龟叔”设计 Python 语言时，直接通过缩进来组织代码块。“缩进”成为了 Python 语法强制的规定。<br />
缩进时，几个空格都是允许的，但是数目必须统一。我们通常采用“四个空格”表示一个缩进。  <br />
同时，也要避免将“tab 制表符”或者 tab 与空格混合的缩进风格。目前，常用的编辑器一般设置成：tab 制表符就是 4 个空格。<br />
Python 官方推荐的 PEP-8 代码风格详细说明，有兴趣的同学可以参考：<br />
<a href="https://www.python.org/dev/peps/pep-0008/">https://www.python.org/dev/peps/pep-0008/</a></p>
<h4 id="_7">使用注释#<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h4>
<p>注释是程序中会被 Python 解释器忽略的一段文本。程序员可以通过注释记录任意想写的内容，通常是关于代码的说明。<br />
Python 中的注释只有单行注释，使用 # 开始直到行结束的部分。<br />
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; # 注释是个好习惯，方便自己方便他人
&gt;&gt;&gt; a = [10,20,30] #生成一个列表对象，变量 a 引用了这个变量
</code></pre></div></p>
<h4 id="_8">使用\行连接符<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h4>
<p>一行程序长度是没有限制的，但是为了可读性更强，通常将一行比较长的程序分为多行。这时，我们可以使用\行连接符，把它放在行结束的地方。Python 解释器仍然将它们解释为同一行。<br />
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = [10,20,30,40,\
50,60,70,\
80,90,100]
&gt;&gt;&gt; a
[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
&gt;&gt;&gt; a = &#39;abcdefghijklmnopqrstuvwxyz&#39;
&gt;&gt;&gt; b = &#39;abcdefg\
hijklmn\
opqrst\
uvwxyz&#39;
&gt;&gt;&gt; a
&#39;abcdefghijklmnopqrstuvwxyz&#39;
&gt;&gt;&gt; b
&#39;abcdefghijklmnopqrstuvwxyz&#39;
</code></pre></div></p>
<h3 id="_9">对象<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h3>
<p>Python 中，一切皆对象。每个对象由：标识（identity）、类型（type）、value（值）组成。<br />
1. 标识用于唯一标识对象，通常对应于对象在计算机内存中的地址。使用内置函数 id(obj)可返回对象 obj 的标识。<br />
2. 类型用于表示对象存储的“数据”的类型。类型可以限制对象的取值范围以及可执行的操作。可以使用 type(obj)获得对象的所属类型。<br />
3. 值表示对象所存储的数据的信息。使用 print(obj)可以直接打印出值。  </p>
<p><strong>对象的本质就是：一个内存块，拥有特定的值，支持特定类型的相关操作。</strong><br />
源码：<br />
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = 3
&gt;&gt;&gt; a
3
&gt;&gt; id(3)
1531372336
&gt;&gt;&gt; type(3)
&lt;class &#39;int&#39;&gt;
&gt;&gt;&gt; b = &quot;我爱你&quot;
&gt;&gt;&gt; id(a)
1531372336
&gt;&gt;&gt; type(a)
&lt;class &#39;int&#39;&gt;
&gt;&gt;&gt; print(a)
3
&gt;&gt; id(b)
46806816
&gt;&gt;&gt; type(b)
&lt;class &#39;str&#39;&gt;
</code></pre></div>
示意图：<br />
<img alt="alt text" src="../image-5.png" />  </p>
<h3 id="_10">引用<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h3>
<p>在 Python 中，变量也称为：对象的引用。因为，变量存储的就是对象的地址。<br />
变量通过地址引用了“对象”。<br />
变量位于：栈内存（压栈出栈等细节，后续再介绍）。<br />
对象位于：堆内存。</p>
<ul>
<li>Python 是动态类型语言<br />
变量不需要显式声明类型。根据变量引用的对象，Python 解释器自动确定数据类型。  </li>
<li>Python 是强类型语言<br />
每个对象都有数据类型，只支持该类型支持的操作。  </li>
</ul>
<p><img alt="alt text" src="../image-6.png" />  </p>
<h3 id="_11">标识符<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h3>
<h4 id="_12">基本用法<a class="headerlink" href="#_12" title="Permanent link">&para;</a></h4>
<p>标识符：用于变量、函数、类、模块等的名称。标识符有如下特定的规则：  </p>
<ol>
<li>区分大小写。如：sxt 和 SXT 是不同的  </li>
<li>第一个字符必须是字母、下划线。其后的字符是：字母、数字、下划线  </li>
<li>不能使用关键字。比如：if、or、while 等。  </li>
<li>以双下划线开头和结尾的名称通常有特殊含义，尽量避免这种写法。比如：__init__是类的构造函数。   </li>
</ol>
<p>【操作】使用 Python 帮助系统查看关键字<br />
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; help()
help&gt; keywords
False   def if  raise  
None    del import  return  
True    elif    in  try  
and else    is  while  
as  except  lambda  with  
assert  finally nonlocal    yield  
break   for not  
class   from    or
continue    global  pass 
</code></pre></div></p>
<h4 id="python_8">Python 标识符命名规则<a class="headerlink" href="#python_8" title="Permanent link">&para;</a></h4>
<p>开发中，我们通常约定俗称遵守如下规则：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>规则</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>模块和包名</td>
<td>全小写字母，尽量简单。若多个单词之间用下划线</td>
<td>math, os, sys</td>
</tr>
<tr>
<td>函数名</td>
<td>全小写字母，多个单词之间用下划线隔开</td>
<td>phone, my_name</td>
</tr>
<tr>
<td>类名</td>
<td>首字母大写，采用驼峰原则。多个单词时，每个单词第一个字母大写，其余部分小写</td>
<td>MyPhone、MyClass、Phone</td>
</tr>
<tr>
<td>常量名</td>
<td>全大写字母，多个单词使用下划线隔开</td>
<td>SPEED、MAX_SPEED</td>
</tr>
</tbody>
</table>
<h3 id="_13">变量和简单赋值语句<a class="headerlink" href="#_13" title="Permanent link">&para;</a></h3>
<h4 id="_14">变量的声明和赋值<a class="headerlink" href="#_14" title="Permanent link">&para;</a></h4>
<p>变量的声明和赋值用于将一个变量绑定到一个对象上，格式如下：<br />
变量名 = 表达式<br />
最简单的表达式就是字面量。比如：a = 123 。 运行过程中，解释器先运行右边的表达式，生成一个代表表达式运算结果的对象；然后，将这个对象地址赋值给左边的变量。 </p>
<p>【操作】变量在使用前必须先被初始化（先被赋值）
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; my_name
Traceback (most recent call last):
File &quot;&lt;pyshell#17&gt;&quot;, line 1, in &lt;module&gt;
my_name
NameError: name &#39;my_name&#39; is not defined
</code></pre></div></p>
<h4 id="_15">删除变量和垃圾回收机制<a class="headerlink" href="#_15" title="Permanent link">&para;</a></h4>
<p>可以通过 del 语句删除不在使用的变量。  </p>
<p>【操作 55】删除变量示例<br />
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; x=123
&gt;&gt;&gt; del x
&gt;&gt;&gt; x
Traceback (most recent call last):
File &quot;&lt;pyshell#20&gt;&quot;, line 1, in &lt;module&gt;
x
NameError: name &#39;x&#39; is not defined
</code></pre></div>
如果对象没有变量引用，就会被垃圾回收器回收，清空内存空间。  </p>
<h4 id="_16">链式赋值<a class="headerlink" href="#_16" title="Permanent link">&para;</a></h4>
<p>链式赋值用于同一个对象赋值给多个变量。<br />
x=y=123 相当于：x=123; y=123  </p>
<h4 id="_17">系列解包赋值<a class="headerlink" href="#_17" title="Permanent link">&para;</a></h4>
<p>系列数据赋值给对应相同个数的变量（个数必须保持一致）<br />
a,b,c=4,5,6 相当于：a=4;b=5;c=6  </p>
<p>【操作】使用系列解包赋值实现变量交换
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a,b=1,2
&gt;&gt;&gt; a,b=b,a
&gt;&gt;&gt; print(a,b)
2 1
</code></pre></div></p>
<h4 id="_18">常量<a class="headerlink" href="#_18" title="Permanent link">&para;</a></h4>
<p>Python 不支持常量，即没有语法规则限制改变一个常量的值。我们只能约定常量的命名规则，以及在程序的逻辑上不对常量的值作出修改。<br />
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; MAX_SPEED = 120
&gt;&gt;&gt; print(MAX_SPEED)
120
&gt;&gt;&gt; MAX_SPEED = 140 #实际是可以改的。只能逻辑上不做修改。
&gt;&gt;&gt; print(MAX_SPEED)
140
</code></pre></div></p>
<h3 id="_19">基本内置数据类型和运算符<a class="headerlink" href="#_19" title="Permanent link">&para;</a></h3>
<p>每个对象都有类型，python 中最基本的内置数据类型：  </p>
<ol>
<li>整型<br />
整数，2345,10,50  </li>
<li>浮点型<br />
小数，3.14 或者科学计数法 314e-2  </li>
<li>布尔型<br />
表示真假，仅包含：True、False  </li>
<li>字符串型<br />
由字符组成的序列。 “abc”,”sxt”,“尚学堂”,”百战程序员”</li>
</ol>
<h4 id="_20">数字和基本运算符<a class="headerlink" href="#_20" title="Permanent link">&para;</a></h4>
<p>Python 支持整数(如：50,520)和浮点数(如：3.14,10.0, 1.23e2)，我们可以对数字做如下运算。<br />
<img alt="alt text" src="../image-7.png" /></p>
<p>【操作】基本运算符的使用
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = 7/2
&gt;&gt;&gt; a
3.5
&gt;&gt;&gt; a = 7//2
&gt;&gt;&gt; a
3 &gt;
&gt;&gt; a = 7%2
&gt;&gt;&gt; a
1 
&gt;&gt; 7%4
3 
&gt;&gt; 2**3
8 &gt;
&gt;&gt; 3/0
Traceback (most recent call last):
File &quot;&lt;pyshell#37&gt;&quot;, line 1, in &lt;module&gt;
3/0
ZeroDivisionError: division by zero
&gt;&gt;&gt; divmod(10,5)
(2, 0)
&gt;&gt;&gt; divmod(10,3)
(3, 1)
</code></pre></div>
除数为 0，会产生异常：
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; 3/0
Traceback (most recent call last):
File &quot;&lt;pyshell#31&gt;&quot;, line 1, in &lt;module&gt;
3/0
ZeroDivisionError: division by zero
</code></pre></div>
使用 divmod()函数同时得到商和余数：
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; divmod(13,3)
(4, 1)
</code></pre></div>
divmod()是一个函数，我们以后会详细介绍。他返回的是一个元组(后续将会学习)。  </p>
<h4 id="_21">整数<a class="headerlink" href="#_21" title="Permanent link">&para;</a></h4>
<p>Python 中，除 10 进制，还有其他三种进制：  </p>
<ul>
<li>0b 或 0B，二进制 0 1  </li>
<li>0o 或 0O，八进制 0 1 2 3 4 5 6 7  </li>
<li>0x 或 0X，十六进制 0 1 2 3 4 5 6 7 8 9 a b c d e f<br />
这三种进制可以非常方便的进行“位运算”操作。位运算知识后续将会介绍。  </li>
</ul>
<p>【操作】测试不同进制
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; 12
12
&gt;&gt;&gt; 0b101
5 
&gt;&gt; 0o19
SyntaxError: invalid syntax
&gt;&gt;&gt; 0o10
8 
&gt;&gt; 0xff
255
&gt;&gt;&gt; 0xf
15
&gt;&gt;&gt; 0x10
16
</code></pre></div></p>
<p>使用 int()实现类型转换：  </p>
<ol>
<li>浮点数直接舍去小数部分。如：int(9.9)结果是：9  </li>
<li>布尔值 True 转为 1，False 转为 0。 如：int(True)结果是 1  </li>
<li>字符串符合整数格式（浮点数格式不行）则直接转成对应整数，否则报错。  </li>
</ol>
<p><div class="highlight"><pre><span></span><code>&gt;&gt;&gt; int(&quot;456&quot;)
456
&gt;&gt;&gt; int(&quot;456abc&quot;)
Traceback (most recent call last):
File &quot;&lt;pyshell#41&gt;&quot;, line 1, in &lt;module&gt;
int(&quot;456abc&quot;)
ValueError: invalid literal for int() with base 10: &#39;456abc&#39;
&gt;&gt;&gt; int(&quot;456.78&quot;)
Traceback (most recent call last):
File &quot;&lt;pyshell#42&gt;&quot;, line 1, in &lt;module&gt;
int(&quot;456.78&quot;)
ValueError: invalid literal for int() with base 10: &#39;456.78&#39;
&gt;&gt;&gt;
</code></pre></div>
自动转型： <br />
整数和浮点数混合运算时，表达式结果自动转型成浮点数。比如：2+8.0 的结果是 10.0  </p>
<p>整数可以有多大？<br />
Python2 中，int 是 32 位，可以存储从-2147483648 到 2147483647 的整数（约±21 亿）。Long 类型是 64 位，可以存储：-2<sup>63--2</sup>63-1 之间的数值。<br />
Python3 中，int 可以存储任意大小的整数，long 被取消。我们甚至可以存储下面的值：<br />
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; googol = 10**100
&gt;&gt;&gt; googol
1000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000
000
</code></pre></div></p>
<p>Googol 也是 Google 最初的名字，这也是 Google 最初的含义。<br />
Python3 中可以做超大数的计算，而不会造成“整数溢出”，这也是 Python 特别适合科学运算的特点。</p>
<h4 id="_22">浮点数<a class="headerlink" href="#_22" title="Permanent link">&para;</a></h4>
<p>浮点数，称为 float。<br />
浮点数用 axb10 形式的科学计数法表示。比如：3.14，表示成：314E-2 或者 314e-2。<br />
这些数字在内存中也是按照科学计数法存储。  </p>
<h4 id="_23">类型转换和四舍五入<a class="headerlink" href="#_23" title="Permanent link">&para;</a></h4>
<ol>
<li>类似于 int()，我们也可以使用 float()将其他类型转化成浮点数。  </li>
<li>整数和浮点数混合运算时，表达式结果自动转型成浮点数。比如：2+8.0 的结果是 10.0  </li>
<li>round(value)可以返回四舍五入的值<br />
注：但不会改变原有值，而是产生新的值  </li>
</ol>
<h4 id="_24">增强型赋值运算符<a class="headerlink" href="#_24" title="Permanent link">&para;</a></h4>
<p>运算符+、-、<em>，/、//、*</em> 和 % 和赋值符 = 结合可以构成“增强型赋值运算符”。<br />
a = a + 1 等价于： a +=1<br />
<img alt="alt text" src="../image-8.png" /></p>
<h4 id="_25">时间的表示<a class="headerlink" href="#_25" title="Permanent link">&para;</a></h4>
<p>计算机中时间的表示是从“1970 年 1 月 1 日 00:00:00”开始，以毫秒（1/1000 秒）进行计算。我们也把 1970 年这个时刻成为“unix 时间点”。<br />
这样，我们就把时间全部用数字来表示了。<br />
<img alt="alt text" src="../image-9.png" /></p>
<p>python 中可以通过 time.time() 获得当前时刻，返回的值是以秒为单位，带微秒（1/1000 毫秒）精度的浮点值。例如：1530167364.8566。
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; import time
&gt;&gt;&gt; b = int(time.time())
&gt;&gt;&gt; b
1530168754
&gt;&gt;&gt; totalMinutes = b/60
&gt;&gt;&gt; totalMinutes
25502812.566666666
&gt;&gt;&gt; totalMinutes = b//60
&gt;&gt;&gt; totalMinutes
25502812
&gt;&gt;&gt; totalHours = totalMinutes//60
&gt;&gt;&gt; totalHours
425046
&gt;&gt;&gt; totalDays = totalHours//24
&gt;&gt;&gt; totalDays
17710
&gt;&gt;&gt; totalYears = totalDays//365
&gt;&gt;&gt; totalYears
48
</code></pre></div></p>
<h4 id="_26">布尔值<a class="headerlink" href="#_26" title="Permanent link">&para;</a></h4>
<p>Python2 中没有布尔值，直接用数字 0 表示 False,用数字 1 表示 True。<br />
Python3 中，把 True 和 False 定义成了关键字，但他们的本质还是 1 和 0，甚至可以和数字相加。
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = True
&gt;&gt;&gt; b = 3
&gt;&gt;&gt; a+b
4
</code></pre></div></p>
<h4 id="_27">比较运算符<a class="headerlink" href="#_27" title="Permanent link">&para;</a></h4>
<p>所有比较运算符返回 1 表示真，返回 0 表示假。这分别与特殊的变量 True 和 False 等价。  </p>
<h4 id="_28">逻辑运算符<a class="headerlink" href="#_28" title="Permanent link">&para;</a></h4>
<p><img alt="alt text" src="../image-10.png" /></p>
<h4 id="_29">同一运算符<a class="headerlink" href="#_29" title="Permanent link">&para;</a></h4>
<p>同一运算符用于比较两个对象的存储单元，实际比较的是对象的地址。<br />
<img alt="alt text" src="../image-11.png" />  </p>
<p>is 与 == 区别：<br />
is 用于判断两个变量引用对象是否为同一个，既比较对象的地址。<br />
== 用于判断引用变量引用对象的值是否相等，默认调用对象的 <strong>eq</strong>()方法。   </p>
<h4 id="_30">整数缓存问题<a class="headerlink" href="#_30" title="Permanent link">&para;</a></h4>
<p>Python 仅仅对比较小的整数对象进行缓存（范围为[-5, 256]）缓存起来，而并非是所有整数对象。需要注意的是，这仅仅是在命令行中执行，而在 Pycharm 或者保存为文件执行，结果是不一样的，这是因为解释器做了一部分优化(范围是[-5,任意正整数])。   </p>
<p><strong>总结</strong></p>
<ol>
<li>is 比较两个对象的 id 值是否相等，是否指向同一个内存地址；</li>
<li>== 比较的是两个对象的内容是否相等，值是否相等；</li>
<li>小整数对象[-5,256]在全局解释器范围内被放入缓存供重复使用； </li>
<li>is 运算符比 == 效率高，在变量和 None 进行比较时，应该使用 is。</li>
</ol>
<p>【操作】同一运算符测试
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = 1000
&gt;&gt;&gt; b = 1000
&gt;&gt;&gt; a == b
True
&gt;&gt;&gt; a is b
False
&gt;&gt;&gt; id(a)
46764560
&gt;&gt;&gt; id(b)
46765216
&gt;&gt;&gt; c = 10
&gt;&gt;&gt; d = 10
&gt;&gt;&gt; c is d
True
&gt;&gt;&gt; id(c)
1388831648
&gt;&gt;&gt; id(d)
1388831648
</code></pre></div></p>
<h4 id="_31">基本运算符<a class="headerlink" href="#_31" title="Permanent link">&para;</a></h4>
<p>我们在前面讲解了“+”、“-”、“*”、“/”、“//”、“%”等运算符，这里我们继续讲解一些其他运算符，并进行学习和测试。
<img alt="alt text" src="../image-12.png" />  </p>
<ol>
<li>比较运算符可以连用，并且含义和我们日常使用完全一致。<br />
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = 4
&gt;&gt;&gt; 3&lt;a&lt;10 #关系运算符可以连用
True
</code></pre></div></li>
<li>位操作<br />
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = 0b11001
&gt;&gt;&gt; b = 0b01000
&gt;&gt;&gt; c = a|b
&gt;&gt;&gt; bin(c) #bin()可以将数字转成二进制表示
&#39;0b11001&#39;
&gt;&gt;&gt; bin(c&amp;b)
&#39;0b1000&#39;
&gt;&gt;&gt; bin(c^b)
&#39;0b10001&#39;
&gt;&gt;&gt; a = 3
&gt;&gt;&gt; a&lt;&lt;2 #左移 1 位相当于乘以 2.左移 2 位，相当于乘以 4
12
&gt;&gt;&gt; a = 8
&gt;&gt;&gt; a&gt;&gt;1 #右移 1 位相当于除以 2.
</code></pre></div></li>
<li>加法操作 <br />
(1) 数字相加 3+2 == &gt; 5  <br />
(2) 字符串拼接 “3”+“2”== &gt; “32”  <br />
(3) 列表、元组等合并 [10,20,30]+[5,10,100] ==&gt;[10,20,30,5,10,100]  </li>
<li>乘法操作<br />
(1) 数字相乘 3*2 ==&gt; 6  <br />
(2) 字符串复制 “sxt”*3 ==&gt; ”sxtsxtsxt”<br />
(3) 列表、元组等复制 [10,20,30]*3 ==&gt; [10,20,30,10,20,30,10,20,30]  </li>
</ol>
<h4 id="_32">复合赋值运算符<a class="headerlink" href="#_32" title="Permanent link">&para;</a></h4>
<p>复合赋值可以让程序更加精炼，提高效率。<br />
<img alt="alt text" src="../image-13.png" /><br />
注：与 C 和 JAVA 不一样，Python 不支持自增(++)和自减(--)  </p>
<h4 id="_33">运算符优先级问题<a class="headerlink" href="#_33" title="Permanent link">&para;</a></h4>
<p>如下优先级，从高到低。<br />
<img alt="alt text" src="../image-14.png" /><br />
实际使用中，记住如下简单的规则即可，复杂的表达式一定要使用小括号组织。  </p>
<ol>
<li>乘除优先加减  </li>
<li>位运算和算术运算 &gt; 比较运算符 &gt; 赋值运算符 &gt; 逻辑运算符   </li>
</ol>
<h2 id="_34">字符串<a class="headerlink" href="#_34" title="Permanent link">&para;</a></h2>
<h3 id="_35">字符串基本特点<a class="headerlink" href="#_35" title="Permanent link">&para;</a></h3>
<p>很多人初学编程时，总是担心自己数学不行，潜意识里认为数学好才能编程。实际上，大多数程序员打交道最多的是“字符串”而不是“数字”。因为，编程是用来解决现实问题的，因此逻辑思维的重要性远远超过数学能力。<br />
字符串的本质是：字符序列。Python 的字符串是不可变的，我们无法对原字符串做任何修改。但，可以将字符串的一部分复制到新创建的字符串，达到“看起来修改”的效果。<br />
Python 不支持单字符类型，单字符也是作为一个字符串使用的。  </p>
<h3 id="_36">字符串的编码<a class="headerlink" href="#_36" title="Permanent link">&para;</a></h3>
<p>Python3 直接支持 Unicode，可以表示世界上任何书面语言的字符。Python3 的字符默认就是 16 位 Unicode 编码，ASCII 码是 Unicode 编码的子集。<br />
使用内置函数 ord()可以把字符转换成对应的 Unicode 码；<br />
使用内置函数 chr()可以把十进制数字转换成对应的字符。<br />
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; ord(&#39;A&#39;)
65
&gt;&gt;&gt; ord(&#39;高&#39;)
39640
&gt;&gt;&gt; chr(66)
&#39;B&#39;
&gt;&gt;&gt; ord(&#39;淇&#39;)
28103
</code></pre></div></p>
<h3 id="_37">引号创建字符串<a class="headerlink" href="#_37" title="Permanent link">&para;</a></h3>
<p>我们可以通过单引号或双引号创建字符串。例如：a=’abc’; b=”sxt”<br />
使用两种引号的好处是可以创建本身就包含引号的字符串，而不用使用转义字符。例如：<br />
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = &quot;I&#39;m a teacher!&quot;  
&gt;&gt;&gt; print(a)  
I&#39;m a teacher!  
&gt;&gt;&gt; b = &#39;my_name is &quot;TOM&quot;&#39; 
&gt;&gt;&gt; print(b) 
my_name is &quot;TOM&quot;
</code></pre></div>
连续三个单引号或三个双引号，可以帮助我们创建多行字符串。例如：<br />
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; resume = &#39;&#39;&#39; name=&quot;gaoqi&quot;
company=&quot;sxt&quot; age=18
lover=&quot;Tom&quot;&#39;&#39;&#39;
&gt;&gt;&gt; print(resume)
name=&quot;gaoqi&quot;
company=&quot;sxt&quot; age=18
lover=&quot;Tom&quot;
</code></pre></div></p>
<h3 id="len">空字符串和 len()函数<a class="headerlink" href="#len" title="Permanent link">&para;</a></h3>
<p>Python 允许空字符串的存在，不包含任何字符且长度为 0。例如：<br />
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; c = &#39;&#39;
&gt;&gt;&gt; len(c)
0 
</code></pre></div>
len()用于计算字符串含有多少字符。例如：
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; d = &#39;abc 尚学堂&#39;
&gt;&gt;&gt; len(d)
6
</code></pre></div></p>
<h3 id="_38">转义字符<a class="headerlink" href="#_38" title="Permanent link">&para;</a></h3>
<p>我们可以使用“+特殊字符”，实现某些难以用字符表示的效果。比如：换行等。常见的转义字符有这些：<br />
<img alt="alt text" src="../image-15.png" />  </p>
<p>【操作】测试转义字符的使用
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = &#39;I\nlove\nU&#39;
&gt;&gt;&gt; a
&#39;I\nlove\nU&#39;
&gt;&gt;&gt; print(a)
I 
love
U 
&gt;&gt;&gt; print(&#39;aaabb\
cccddd&#39;)
aaabbcccddd
</code></pre></div></p>
<h3 id="_39">字符串拼接<a class="headerlink" href="#_39" title="Permanent link">&para;</a></h3>
<ol>
<li>可以使用 + 将多个字符串拼接起来。例如：’aa’+ ’bb’ ==&gt;’aabb’。  <br />
(1) 如果+两边都是字符串，则拼接。<br />
(2) 如果+两边都是数字，则加法运算。<br />
(3) 如果+两边类型不同，则抛出异常。  </li>
<li>可以将多个字面字符串直接放到一起实现拼接。例如：’aa’’bb’==&gt;’aabb’  </li>
</ol>
<p>【操作】字符串拼接操作
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = &#39;sxt&#39;+&#39;gaoqi&#39;
&gt;&gt;&gt; a
&#39;sxtgaoqi&#39;
&gt;&gt;&gt; b = &#39;sxt&#39;&#39;gaoqi&#39;
&gt;&gt;&gt; b
&#39;sxtgaoqi&#39;
</code></pre></div></p>
<h3 id="_40">字符串复制<a class="headerlink" href="#_40" title="Permanent link">&para;</a></h3>
<p>使用*可以实现字符串复制。</p>
<p>【操作】字符串复制操作
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = &#39;Sxt&#39;*3
&gt;&gt;&gt; a
&#39;SxtSxtSxt&#39;
</code></pre></div></p>
<h3 id="_41">不换行打印<a class="headerlink" href="#_41" title="Permanent link">&para;</a></h3>
<p>我们前面调用 print 时，会自动打印一个换行符。有时，我们不想换行，不想自动添加换行符。我们可以自己通过参数 end = “任意字符串”。实现末尾添加任何内容：<br />
建立源文件 mypy_06.py：<br />
<div class="highlight"><pre><span></span><code>print(&quot;sxt&quot;,end=&#39; &#39;)
print(&quot;sxt&quot;,end=&#39;##&#39;)
print(&quot;sxt&quot;)
</code></pre></div>
运行结果：
<div class="highlight"><pre><span></span><code>sxt sxt##sxt
</code></pre></div></p>
<h3 id="_42">从控制台读取字符串<a class="headerlink" href="#_42" title="Permanent link">&para;</a></h3>
<p>我们可以使用 input()从控制台读取键盘输入的内容。<br />
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; myname = input(&quot;请输入名字:&quot;)
请输入名字:高淇
&gt;&gt;&gt; myname
&#39;高淇&#39;
</code></pre></div></p>
<h3 id="str">str()实现数字转型字符串<a class="headerlink" href="#str" title="Permanent link">&para;</a></h3>
<p>str()可以帮助我们将其他数据类型转换为字符串。例如：  </p>
<p>str(5.20) == &gt; ‘5.20’ <br />
str(3.14e2)== &gt;’314.0’ <br />
str(True) == &gt; ‘True’  </p>
<p>当我们调用 print()函数时，解释器自动调用了 str() 将非字符串的对象转成了字符串。我们在面向对象章节中详细讲解这部分内容。</p>
<h3 id="_43">使用[]提取字符<a class="headerlink" href="#_43" title="Permanent link">&para;</a></h3>
<p>字符串的本质就是字符序列，我们可以通过在字符串后面添加[]，在[]里面指定偏移量，可以提取该位置的单个字符。<br />
正向搜索：<br />
最左侧第一个字符，偏移量是 0，第二个偏移量是 1，以此类推。直到 len(str)-1为止。<br />
反向搜索：<br />
最右侧第一个字符，偏移量是-1，倒数第二个偏移量是-2，以此类推，直到-len(str)为止。</p>
<p>【操作】使用[]提取字符串中的字符
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = &#39;abcdefghijklmnopqrstuvwxyz&#39;
&gt;&gt;&gt; a
&#39;abcdefghijklmnopqrstuvwxyz&#39;
&gt;&gt;&gt; a[0]
&#39;a&#39;
&gt;&gt;&gt; a[3]
&#39;d&#39;
&gt;&gt;&gt; a[26-1]
&#39;z&#39;
&gt;&gt;&gt; a[-1]
&#39;z&#39;
&gt;&gt;&gt; a[-26]
&#39;a&#39;
&gt;&gt;&gt; a[-30]
Traceback (most recent call last):
File &quot;&lt;pyshell#91&gt;&quot;, line 1, in &lt;module&gt;
a[-30]
IndexError: string index out of range
</code></pre></div></p>
<h3 id="replace">replace()实现字符串替换<a class="headerlink" href="#replace" title="Permanent link">&para;</a></h3>
<p>字符串是“不可改变”的，我们通过[]可以获取字符串指定位置的字符，但是我们不能改变字符串。我们尝试改变字符串中某个字符，发现报错了：<br />
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = &#39;abcdefghijklmnopqrstuvwxyz&#39;
&gt;&gt;&gt; a
&#39;abcdefghijklmnopqrstuvwxyz&#39;
&gt;&gt;&gt; a[3]=&#39;高&#39;
Traceback (most recent call last):
File &quot;&lt;pyshell#94&gt;&quot;, line 1, in &lt;module&gt;
a[3]=&#39;高&#39;
TypeError: &#39;str&#39; object does not support item assignment
</code></pre></div></p>
<p>字符串不可改变。但是，我们确实有时候需要替换某些字符。这时，只能通过创建新的字符串来实现。
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = &#39;abcdefghijklmnopqrstuvwxyz&#39;
&gt;&gt;&gt; a
&#39;abcdefghijklmnopqrstuvwxyz&#39;
&gt;&gt;&gt; a = a.replace(&#39;c&#39;,&#39;高&#39;)
&#39;ab 高 defghijklmnopqrstuvwxyz&#39;
</code></pre></div>
整个过程中，实际上我们是创建了新的字符串对象，并指向了变量 a，而不是修改了以前的字符串。 内存图如下：<br />
<img alt="alt text" src="../image-16.png" />  </p>
<h3 id="slice">字符串切片 slice 操作<a class="headerlink" href="#slice" title="Permanent link">&para;</a></h3>
<p>切片 slice 操作可以让我们快速的提取子字符串。标准格式为：<br />
[起始偏移量 start：终止偏移量 end：步长 step]  </p>
<p>典型操作(三个量为正数的情况)如下：<br />
<img alt="alt text" src="../image-17.png" />  </p>
<p>其他操作（三个量为负数）的情况：<br />
<img alt="alt text" src="../image-18.png" />  </p>
<p>切片操作时，起始偏移量和终止偏移量不在[0,字符串长度-1]这个范围，也不会报错。起始偏移量小于 0 则会当做 0，终止偏移量大于“长度-1”会被当成-1。例如：
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; &quot;abcdefg&quot;[3:50]
&#39;defg&#39;
</code></pre></div>
我们发现正常输出了结果，没有报错。  </p>
<h3 id="split-join">split()分割和 join()合并<a class="headerlink" href="#split-join" title="Permanent link">&para;</a></h3>
<p>split()可以基于指定分隔符将字符串分隔成多个子字符串(存储到列表中)。如果不指定分隔符，则默认使用空白字符(换行符/空格/制表符)。示例代码如下：
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = &quot;to be or not to be&quot;
&gt;&gt;&gt; a.split()
[&#39;to&#39;, &#39;be&#39;, &#39;or&#39;, &#39;not&#39;, &#39;to&#39;, &#39;be&#39;]
&gt;&gt;&gt; a.split(&#39;be&#39;)
[&#39;to &#39;, &#39; or not to &#39;, &#39;&#39;]
</code></pre></div></p>
<p>join()的作用和 split()作用刚好相反，用于将一系列子字符串连接起来。示例代码如下：
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = [&#39;sxt&#39;,&#39;sxt100&#39;,&#39;sxt200&#39;]
&gt;&gt;&gt; &#39;*&#39;.join(a)
&#39;sxt*sxt100*sxt200&#39;
</code></pre></div></p>
<p>拼接字符串要点：<br />
使用字符串拼接符+，会生成新的字符串对象，因此不推荐使用+来拼接字符串。推荐使用 join 函数，因为 join 函数在拼接字符串之前会计算所有字符串的长度，然后逐一拷贝，仅新建一次对象。  </p>
<p>【操作】测试+拼接符和 join()，不同的效率 (mypy_07.py)
<div class="highlight"><pre><span></span><code>import time
time01 = time.time() #起始时刻
a = &quot;&quot;
for i in range(1000000):
a += &quot;sxt&quot;
time02 = time.time() #终止时刻
print(&quot;运算时间：&quot;+str(time02-time01))
time03 = time.time() #起始时刻
li = []
for i in range(1000000):
li.append(&quot;sxt&quot;)
a = &quot;&quot;.join(li)
time04 = time.time() #终止时刻
print(&quot;运算时间：&quot;+str(time04-time03))
</code></pre></div></p>
<h3 id="_44">字符串驻留机制和字符串比较<a class="headerlink" href="#_44" title="Permanent link">&para;</a></h3>
<p>字符串驻留：仅保存一份相同且不可变字符串的方法，不同的值被存放在字符串驻留池中。<br />
Python 支持字符串驻留机制，对于符合标识符规则的字符串（仅包含下划线（_）、字母和数字）会启用字符串驻留机制驻留机制。 
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = &quot;abd_33&quot;
&gt;&gt;&gt; b = &quot;abd_33&quot;
&gt;&gt;&gt; a is b
True
&gt;&gt;&gt; c = &quot;dd#&quot;
&gt;&gt;&gt; d = &quot;dd#&quot;
&gt;&gt;&gt; c is d
False
&gt;&gt;&gt; str1 = &quot;aa&quot;
&gt;&gt;&gt; str2 = &quot;bb&quot;
&gt;&gt;&gt; str1+str2 is &quot;aabb&quot;
False
&gt;&gt;&gt; str1+str2 == &quot;aabb&quot;
True
</code></pre></div></p>
<h3 id="_45">字符串比较和同一性<a class="headerlink" href="#_45" title="Permanent link">&para;</a></h3>
<p>我们可以直接使用==,!=对字符串进行比较，是否含有相同的字符。<br />
我们使用 is / not is，判断两个对象是否同一个对象。比较的是对象的地址，即 id(obj1)是否和 id(obj2)相等。</p>
<h3 id="_46">成员操作符<a class="headerlink" href="#_46" title="Permanent link">&para;</a></h3>
<p>in /not in 关键字，判断某个字符(子字符串)是否存在于字符串中。  </p>
<h3 id="_47">字符串常用方法汇总<a class="headerlink" href="#_47" title="Permanent link">&para;</a></h3>
<p>字符串有很多常用的方法，我们需要熟悉。我们通过表格将这些方法汇总起来，方便大家查阅。希望大家针对每个方法都做一次测试。</p>
<h4 id="_48">常用查找方法<a class="headerlink" href="#_48" title="Permanent link">&para;</a></h4>
<p>我们以一段文本作为测试：<br />
a='''我是高淇,今年 18 岁了,我在北京尚学堂科技上班。我的儿子叫高洛希，他 6 岁了。我是一个编程教育的普及者，希望影响 6000 万学习编程的中国人。我儿子现在也开始学习编程，希望他 18 岁的时候可以超过我'''</p>
<table>
<thead>
<tr>
<th>方法和使用示例</th>
<th>说明</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>len(a)</td>
<td>字符串长度</td>
<td>96</td>
</tr>
<tr>
<td>a.startswith('我是高淇')</td>
<td>以指定字符串开头</td>
<td>True</td>
</tr>
<tr>
<td>a.endswith('过我')</td>
<td>以指定字符串结尾</td>
<td>True</td>
</tr>
<tr>
<td>a.find('高')</td>
<td>第一次出现指定字符串的位置</td>
<td>2</td>
</tr>
<tr>
<td>a.rfind('高')</td>
<td>最后一次出现指定字符串的位置</td>
<td>29</td>
</tr>
<tr>
<td>a.count("编程")</td>
<td>指定字符串出现了几次</td>
<td>3</td>
</tr>
<tr>
<td>a.isalnum()</td>
<td>所有字符全是字母或数字</td>
<td>False</td>
</tr>
</tbody>
</table>
<h4 id="_49">去除首尾信息<a class="headerlink" href="#_49" title="Permanent link">&para;</a></h4>
<p>我们可以通过 strip()去除字符串首尾指定信息。通过 lstrip()去除字符串左边指定信息，rstrip()去除字符串右边指定信息。  </p>
<p>【操作】去除字符串首尾信息
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; &quot;*s*x*t*&quot;.strip(&quot;*&quot;)
&#39;s*x*t&#39;
&gt;&gt;&gt; &quot;*s*x*t*&quot;.lstrip(&quot;*&quot;)
&#39;s*x*t*&#39;
&gt;&gt;&gt; &quot;*s*x*t*&quot;.rstrip(&quot;*&quot;)
&#39;*s*x*t&#39;
&gt;&gt;&gt; &quot; sxt &quot;.strip()
&#39;sxt&#39;
</code></pre></div></p>
<h4 id="_50">大小写转换<a class="headerlink" href="#_50" title="Permanent link">&para;</a></h4>
<p>编程中关于字符串大小写转换的情况，经常遇到。我们将相关方法汇总到这里。为了方便学习，先设定一个测试变量：<br />
a = "gaoqi love programming, love SXT"</p>
<table>
<thead>
<tr>
<th>示例</th>
<th>说明</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>a.capitalize()</td>
<td>产生新的字符串,首字母大写</td>
<td>'Gaoqi love programming, love sxt'</td>
</tr>
<tr>
<td>a.title()</td>
<td>产生新的字符串,每个单词都首字母大写</td>
<td>'Gaoqi Love Programming, Love Sxt'</td>
</tr>
<tr>
<td>a.upper()</td>
<td>产生新的字符串,所有字符全转成大写</td>
<td>'GAOQI LOVE PROGRAMMING, LOVE SXT'</td>
</tr>
<tr>
<td>a.lower()</td>
<td>产生新的字符串,所有字符全转成小写</td>
<td>'gaoqi love programming, love sxt'</td>
</tr>
<tr>
<td>a.swapcase()</td>
<td>产生新的,所有字母大小写转换</td>
<td>'GAOQI LOVE PROGRAMMING, LOVE sxt</td>
</tr>
</tbody>
</table>
<h4 id="_51">格式排版<a class="headerlink" href="#_51" title="Permanent link">&para;</a></h4>
<p>center()、ljust()、rjust()这三个函数用于对字符串实现排版。示例如下：
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a=&quot;SXT&quot;
&gt;&gt;&gt; a.center(10,&quot;*&quot;)
&#39;***SXT****&#39;
&gt;&gt;&gt; a.center(10)
&#39; SXT &#39;
&gt;&gt;&gt; a.ljust(10,&quot;*&quot;)
&#39;SXT*******&#39;
</code></pre></div></p>
<h4 id="_52">其他方法<a class="headerlink" href="#_52" title="Permanent link">&para;</a></h4>
<ol>
<li>isalnum() 是否为字母或数字  </li>
<li>isalpha() 检测字符串是否只由字母组成(含汉字)  </li>
<li>isdigit() 检测字符串是否只由数字组成   </li>
<li>isspace() 检测是否为空白符  </li>
<li>isupper() 是否为大写字母  </li>
<li>islower() 是否为小写字母  </li>
</ol>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; &quot;sxt100&quot;.isalnum()
True
&gt;&gt;&gt; &quot;sxt 尚学堂&quot;.isalpha()
True
&gt;&gt;&gt; &quot;234.3&quot;.isdigit()
False
&gt;&gt;&gt; &quot;23423&quot;.isdigit()
True
&gt;&gt;&gt; &quot;aB&quot;.isupper()
False
&gt;&gt;&gt; &quot;A&quot;.isupper()
True
&gt;&gt;&gt; &quot;\t\n&quot;.isspace()
True
</code></pre></div>
<h3 id="_53">字符串的格式化<a class="headerlink" href="#_53" title="Permanent link">&para;</a></h3>
<h4 id="format">format()基本用法<a class="headerlink" href="#format" title="Permanent link">&para;</a></h4>
<p>Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能。<br />
基本语法是通过 {} 和 : 来代替以前的 % 。<br />
format 函数可以接受不限个参数，位置可以不按顺序。<br />
我们通过示例进行格式化的学习。<br />
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = &quot;名字是:{0},年龄是：{1}&quot;
&gt;&gt;&gt; a.format(&quot;高淇&quot;,18)
&#39;名字是:高淇,年龄是：18&#39;
&gt;&gt;&gt; a.format(&quot;高希希&quot;,6)
&#39;名字是:高希希,年龄是：6&#39;
&gt;&gt;&gt; b = &quot;名字是：{0}，年龄是{1}。{0}是个好小伙&quot;
&gt;&gt;&gt; b.format(&quot;高淇&quot;,18)
&#39;名字是：高淇，年龄是 18。高淇是个好小伙&#39;
&gt;&gt;&gt; c = &quot;名字是{name}，年龄是{age}&quot;
&gt;&gt;&gt; c.format(age=19,name=&#39;高淇&#39;)
&#39;名字是高淇，年龄是 19&#39;
</code></pre></div>
我们可以通过{索引}/{参数名}，直接映射参数值，实现对字符串的格式化，非常方便。</p>
<h4 id="_54">填充与对齐<a class="headerlink" href="#_54" title="Permanent link">&para;</a></h4>
<p>填充常跟对齐一起使用<br />
^、&lt;、&gt;分别是居中、左对齐、右对齐，后面带宽度<br />
:号后面带填充的字符，只能是一个字符，不指定的话默认是用空格填充<br />
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; &quot;{:*&gt;8}&quot;.format(&quot;245&quot;)  
&#39;*****245&#39; 
&gt;&gt;&gt; &quot;我是{0},我喜欢数字{1:*^8}&quot;.format(&quot;高淇&quot;,&quot;666&quot;)
&#39;我是高淇,我喜欢数字**666***&#39;
</code></pre></div></p>
<h4 id="_55">数字格式化<a class="headerlink" href="#_55" title="Permanent link">&para;</a></h4>
<p>浮点数通过 f，整数通过 d 进行需要的格式化。案例如下：
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = &quot;我是{0}，我的存款有{1:.2f}&quot;
&gt;&gt;&gt; a.format(&quot;高淇&quot;,3888.234342)
&#39;我是高淇，我的存款有 3888.23&#39;
</code></pre></div></p>
<p>其他格式，供大家参考：<br />
<img alt="alt text" src="../image-19.png" /></p>
<h3 id="_56">可变字符串<a class="headerlink" href="#_56" title="Permanent link">&para;</a></h3>
<p>在 Python 中，字符串属于不可变对象，不支持原地修改，如果需要修改其中的值，只能创建新的字符串对象。但是，经常我们确实需要原地修改字符串，可以使用 io.StringIO 对象或 array 模块。
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; import io
&gt;&gt;&gt; s = &quot;hello, sxt&quot;
&gt;&gt;&gt; sio = io.StringIO(s)
&gt;&gt;&gt; sio
&lt;_io.StringIO object at 0x02F462B0&gt;
&gt;&gt;&gt; sio.getvalue()
&#39;hello, sxt&#39;
&gt;&gt;&gt; sio.seek(7)
7 
&gt;&gt;&gt; sio.write(&quot;g&quot;)
1 
&gt;&gt;&gt; sio.getvalue()
&#39;hello, gxt&#39;
</code></pre></div></p>
<h2 id="_57">序列<a class="headerlink" href="#_57" title="Permanent link">&para;</a></h2>
<p>序列是一种数据存储方式，用来存储一系列的数据。在内存中，序列就是一块用来存放多个值的连续的内存空间。比如一个整数序列[10,20,30,40]，可以这样示意表示：  </p>
<p><img alt="alt text" src="../image-20.png" /><br />
由于 Python3 中一切皆对象，在内存中实际是按照如下方式存储的： </p>
<p><img alt="alt text" src="../image-21.png" /><br />
从图示中，我们可以看出序列中存储的是整数对象的地址，而不是整数对象的值。python中常用的序列结构有：<br />
字符串、列表、元组、字典、集合<br />
我们上一章学习的字符串就是一种序列。关于字符串里面很多操作，在这一章中仍然会用到，大家一定会感觉非常熟悉。<br />
本章内容，我们必须非常熟悉。无论是在学习还是工作中，序列都是每天都会用到的技术，可以非常方便的帮助我们进行数据存储的操作。  </p>
<h3 id="_58">列表简介<a class="headerlink" href="#_58" title="Permanent link">&para;</a></h3>
<p>列表：用于存储任意数目、任意类型的数据集合。<br />
列表是内置可变序列，是包含多个元素的有序连续的内存空间。列表定义的标准语法格式：<br />
a = [10,20,30,40]<br />
其中，10,20,30,40 这些称为：列表 a 的元素。<br />
列表中的元素可以各不相同，可以是任意类型。比如： <br />
a = [10,20,'abc',True]<br />
列表对象的常用方法汇总如下，方便大家学习和查阅。  </p>
<p><img alt="alt text" src="../image-22.png" /><br />
Python 的列表大小可变，根据需要随时增加或缩小。  </p>
<p>字符串和列表都是序列类型，一个字符串是一个字符序列，一个列表是任何元素的序列。我们前面学习的很多字符串的方法，在列表中也有类似的用法，几乎一模一样。  </p>
<h3 id="_59">列表的创建<a class="headerlink" href="#_59" title="Permanent link">&para;</a></h3>
<h4 id="_60">基本语法[]创建<a class="headerlink" href="#_60" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = [10,20,&#39;gaoqi&#39;,&#39;sxt&#39;]
&gt;&gt;&gt; a = [] #创建一个空的列表对象
</code></pre></div>
<h4 id="list">list()创建<a class="headerlink" href="#list" title="Permanent link">&para;</a></h4>
<p>使用 list()可以将任何可迭代的数据转化成列表。<br />
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = list() #创建一个空的列表对象
&gt;&gt;&gt; a = list(range(10))
&gt;&gt;&gt; a
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; a = list(&quot;gaoqi,sxt&quot;)
&gt;&gt;&gt; a
[&#39;g&#39;, &#39;a&#39;, &#39;o&#39;, &#39;q&#39;, &#39;i&#39;, &#39;,&#39;, &#39;s&#39;, &#39;x&#39;, &#39;t&#39;]
</code></pre></div></p>
<h4 id="range">range()创建整数列表<a class="headerlink" href="#range" title="Permanent link">&para;</a></h4>
<p>range()可以帮助我们非常方便的创建整数列表，这在开发中及其有用。语法格式为：<br />
range([start,] end [,step])<br />
start 参数：可选，表示起始数字。默认是 0<br />
end 参数：必选，表示结尾数字。<br />
step 参数：可选，表示步长，默认为 1<br />
python3 中 range()返回的是一个 range 对象，而不是列表。我们需要通过 list()方法将其转换成列表对象。<br />
典型示例如下：<br />
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; list(range(3,15,2))
[3, 5, 7, 9, 11, 13]
&gt;&gt;&gt; list(range(15,3,-1))
[15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4]
&gt;&gt;&gt; list(range(3,-10,-1))
[3, 2, 1, 0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
</code></pre></div></p>
<h4 id="_61">推导式生成列表<a class="headerlink" href="#_61" title="Permanent link">&para;</a></h4>
<p>使用列表推导式可以非常方便的创建列表，在开发中经常使用。但是，由于涉及到 for 循环和 if 语句。在此，仅做基本介绍。在我们控制语句后面，会详细讲解更多列表推导式的细节。
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = [x*2 for x in range(5)] #循环创建多个元素
&gt;&gt;&gt; a
[0, 2, 4, 6, 8]
&gt;&gt;&gt; a = [x*2 for x in range(100) if x%9==0] #通过 if 过滤元素
&gt;&gt;&gt; a
[0, 18, 36, 54, 72, 90, 108, 126, 144, 162, 180, 198]
</code></pre></div></p>
<h3 id="_62">列表元素的增加<a class="headerlink" href="#_62" title="Permanent link">&para;</a></h3>
<p>当列表增加和删除元素时，列表会自动进行内存管理，大大减少了程序员的负担。但这个特点涉及列表元素的大量移动，效率较低。除非必要，我们一般只在列表的尾部添加元素或删除元素，这会大大提高列表的操作效率。  </p>
<h4 id="append">append()方法<a class="headerlink" href="#append" title="Permanent link">&para;</a></h4>
<p>原地修改列表对象，是真正的列表尾部添加新的元素，速度最快，推荐使用。<br />
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = [20,40]
&gt;&gt;&gt; a.append(80)
&gt;&gt;&gt; a
[20, 40, 80]
</code></pre></div></p>
<h4 id="_63">+运算符操作<a class="headerlink" href="#_63" title="Permanent link">&para;</a></h4>
<p>并不是真正的尾部添加元素，而是创建新的列表对象；将原列表的元素和新列表的元素依次复制到新的列表对象中。这样，会涉及大量的复制操作，对于操作大量元素不建议使用。
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = [20,40]
&gt;&gt;&gt; id(a)
46016072
&gt;&gt;&gt; a = a+[50]
&gt;&gt;&gt; id(a)
46015432
</code></pre></div>
通过如上测试，我们发现变量 a 的地址发生了变化。也就是创建了新的列表对象。</p>
<h4 id="extend">extend()方法<a class="headerlink" href="#extend" title="Permanent link">&para;</a></h4>
<p>将目标列表的所有元素添加到本列表的尾部，属于原地操作，不创建新的列表对象。
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = [20,40]
&gt;&gt;&gt; id(a)
46016072
&gt;&gt;&gt; a.extend([50,60])
&gt;&gt;&gt; id(a)
46016072
</code></pre></div></p>
<h4 id="insert">insert()插入元素<a class="headerlink" href="#insert" title="Permanent link">&para;</a></h4>
<p>使用 insert()方法可以将指定的元素插入到列表对象的任意制定位置。这样会让插入位置后面所有的元素进行移动，会影响处理速度。涉及大量元素时，尽量避免使用。类似发生这种移动的函数还有：remove()、pop()、del()，它们在删除非尾部元素时也会发生操作位置后面元素的移动。
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = [10,20,30]
&gt;&gt;&gt; a.insert(2,100)
&gt;&gt;&gt; a
[10, 20, 100, 30]
</code></pre></div></p>
<h4 id="_64">乘法扩展<a class="headerlink" href="#_64" title="Permanent link">&para;</a></h4>
<p>使用乘法扩展列表，生成一个新列表，新列表元素时原列表元素的多次重复。
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = [&#39;sxt&#39;,100]
&gt;&gt;&gt; b = a*3
&gt;&gt;&gt; a
[&#39;sxt&#39;, 100]
&gt;&gt;&gt; b
[&#39;sxt&#39;, 100, &#39;sxt&#39;, 100, &#39;sxt&#39;, 100]
</code></pre></div>
适用于乘法操作的，还有：字符串、元组。例如：
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; c = &#39;sxt&#39;
&gt;&gt;&gt; d = c*3
&gt;&gt;&gt; c
&#39;sxt&#39;
&gt;&gt;&gt; d
&#39;sxtsxtsxt&#39;
</code></pre></div></p>
<h3 id="_65">列表元素的删除<a class="headerlink" href="#_65" title="Permanent link">&para;</a></h3>
<h4 id="del">del 删除<a class="headerlink" href="#del" title="Permanent link">&para;</a></h4>
<p>删除列表指定位置的元素。
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = [100,200,888,300,400]
&gt;&gt;&gt; del a[2]
&gt;&gt;&gt; a
[100,200,300,400]
</code></pre></div>
<img alt="alt text" src="../image-23.png" /></p>
<h4 id="pop">pop()方法<a class="headerlink" href="#pop" title="Permanent link">&para;</a></h4>
<p>pop()删除并返回指定位置元素，如果未指定位置则默认操作列表最后一个元素。
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = [10,20,30,40,50]
&gt;&gt;&gt; a.pop()
50
&gt;&gt;&gt; a
[10, 20, 30, 40]
&gt;&gt;&gt; a.pop(1)
20
&gt;&gt;&gt; a
[10, 30, 40]
</code></pre></div></p>
<h4 id="remove">remove()方法<a class="headerlink" href="#remove" title="Permanent link">&para;</a></h4>
<p>删除首次出现的指定元素，若不存在该元素抛出异常。
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = [10,20,30,40,50,20,30,20,30]
&gt;&gt;&gt; a.remove(20)
&gt;&gt;&gt; a
[10, 30, 40, 50, 20, 30, 20, 30]
&gt;&gt;&gt; a.remove(100)
Traceback (most recent call last):
File &quot;&lt;pyshell#208&gt;&quot;, line 1, in &lt;module&gt;
a.remove(100)
ValueError: list.remove(x): x not in list
</code></pre></div></p>
<h3 id="_66">列表元素访问和计数<a class="headerlink" href="#_66" title="Permanent link">&para;</a></h3>
<h4 id="_67">通过索引直接访问元素<a class="headerlink" href="#_67" title="Permanent link">&para;</a></h4>
<p>我们可以通过索引直接访问元素。索引的区间在[0, 列表长度-1]这个范围。超过这个范围则会抛出异常。
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = [10,20,30,40,50,20,30,20,30]
&gt;&gt;&gt; a[2]
30
&gt;&gt;&gt; a[10]
Traceback (most recent call last):
File &quot;&lt;pyshell#211&gt;&quot;, line 1, in &lt;module&gt;
a[10]
IndexError: list index out of range
</code></pre></div></p>
<h4 id="index">index()获得指定元素在列表中首次出现的索引<a class="headerlink" href="#index" title="Permanent link">&para;</a></h4>
<p>index()可以获取指定元素首次出现的索引位置。语法是：index(value,[start,[end]])。其中，start 和 end 指定了搜索的范围。
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = [10,20,30,40,50,20,30,20,30]
&gt;&gt;&gt; a.index(20)
1 
&gt;&gt;&gt; a.index(20,3)
5 
&gt;&gt;&gt; a.index(20,3) #从索引位置 3 开始往后搜索的第一个 20
5 
&gt;&gt;&gt; a.index(30,5,7) #从索引位置 5 到 7 这个区间，第一次出现 30 元素的位置
6 
</code></pre></div></p>
<h4 id="count">count()获得指定元素在列表中出现的次数<a class="headerlink" href="#count" title="Permanent link">&para;</a></h4>
<p>count()可以返回指定元素在列表中出现的次数。
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = [10,20,30,40,50,20,30,20,30]
&gt;&gt;&gt; a.count(20)
3 
</code></pre></div></p>
<h4 id="len_1">len()返回列表长度<a class="headerlink" href="#len_1" title="Permanent link">&para;</a></h4>
<p>len()返回列表长度，即列表中包含元素的个数。
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = [10,20,30]
&gt;&gt;&gt; len(a)
3
</code></pre></div></p>
<h4 id="_68">成员资格判断<a class="headerlink" href="#_68" title="Permanent link">&para;</a></h4>
<p>判断列表中是否存在指定的元素，我们可以使用 count()方法，返回 0 则表示不存在，返回大于 0 则表示存在。但是，一般我们会使用更加简洁的 in 关键字来判断，直接返回 True 或 False。
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = [10,20,30,40,50,20,30,20,30]
&gt;&gt;&gt; 20 in a
True
&gt;&gt;&gt; 100 not in a
True
&gt;&gt;&gt; 30 not in a
False
</code></pre></div></p>
<h3 id="_69">切片操作<a class="headerlink" href="#_69" title="Permanent link">&para;</a></h3>
<p>我们在前面学习字符串时，学习过字符串的切片操作，对于列表的切片操作和字符串类似。<br />
切片是 Python 序列及其重要的操作，适用于列表、元组、字符串等等。切片的格式如下：<br />
切片 slice 操作可以让我们快速提取子列表或修改。标准格式为：<br />
[起始偏移量 start:终止偏移量 end[:步长 step]]<br />
注：当步长省略时顺便可以省略第二个冒号<br />
典型操作(三个量为正数的情况)如下： </p>
<p><img alt="alt text" src="../image-24.png" /></p>
<p>其他操作（三个量为负数）的情况：</p>
<p><img alt="alt text" src="../image-25.png" /></p>
<p>切片操作时，起始偏移量和终止偏移量不在[0,字符串长度-1]这个范围，也不会报错。起始偏移量小于 0 则会当做 0，终止偏移量大于“长度-1”会被当成”长度-1”。例如：
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; [10,20,30,40][1:30]
[20, 30, 40]
</code></pre></div>
我们发现正常输出了结果，没有报错。</p>
<h3 id="_70">列表的遍历<a class="headerlink" href="#_70" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>for obj in listObj:
print(obj)
</code></pre></div>
<h3 id="_71">复制列表所有的元素到新列表对象<a class="headerlink" href="#_71" title="Permanent link">&para;</a></h3>
<p>如下代码实现列表元素的复制了吗？<br />
<div class="highlight"><pre><span></span><code>list1 = [30,40,50]  
list2 = list1  
</code></pre></div>
只是将 list2 也指向了列表对象，也就是说 list2 和 list2 持有地址值是相同的，列表对象本身的元素并没有复制。  <br />
我们可以通过如下简单方式，实现列表元素内容的复制：
<div class="highlight"><pre><span></span><code>list1 = [30,40,50]
list2 = [] + list1
</code></pre></div>
注：我们后面也会学习 copy 模块，使用浅复制或深复制实现我们的复制操作。</p>
<h3 id="_72">列表排序<a class="headerlink" href="#_72" title="Permanent link">&para;</a></h3>
<h4 id="_73">修改原列表，不建新列表的排序<a class="headerlink" href="#_73" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = [20,10,30,40]
&gt;&gt;&gt; id(a)
46017416
&gt;&gt;&gt; a.sort() #默认是升序排列
&gt;&gt;&gt; a
[10, 20, 30, 40]
&gt;&gt;&gt; a = [10,20,30,40]
&gt;&gt;&gt; a.sort(reverse=True) #降序排列
&gt;&gt;&gt; a
[40, 30, 20, 10]
&gt;&gt;&gt; import random
&gt;&gt;&gt; random.shuffle(a) #打乱顺序
&gt;&gt;&gt; a
[20, 40, 30, 10]
</code></pre></div>
<h4 id="_74">建新列表的排序<a class="headerlink" href="#_74" title="Permanent link">&para;</a></h4>
<p>我们也可以通过内置函数 sorted()进行排序，这个方法返回新列表，不对原列表做修改。
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = [20,10,30,40]
&gt;&gt;&gt; id(a)
46016008
&gt;&gt;&gt; a = sorted(a) #默认升序
&gt;&gt;&gt; a
[10, 20, 30, 40]
&gt;&gt;&gt; id(a)
45907848
&gt;&gt;&gt; a = [20,10,30,40]
&gt;&gt;&gt; id(a)
45840584
&gt;&gt;&gt; b = sorted(a)
&gt;&gt;&gt; b
[10, 20, 30, 40]
&gt;&gt;&gt; id(a)
45840584
&gt;&gt;&gt; id(b)
46016072
&gt;&gt;&gt; c = sorted(a,reverse=True) #降序
&gt;&gt;&gt; c
[40, 30, 20, 10]
</code></pre></div>
通过上面操作，我们可以看出，生成的列表对象 b 和 c 都是完全新的列表对象。</p>
<h4 id="reversed">reversed()返回迭代器<a class="headerlink" href="#reversed" title="Permanent link">&para;</a></h4>
<p>内置函数 reversed()也支持进行逆序排列，与列表对象 reverse()方法不同的是，内置函数reversed()不对原列表做任何修改，只是返回一个逆序排列的迭代器对象。
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = [20,10,30,40]
&gt;&gt;&gt; c = reversed(a)
&gt;&gt;&gt; c
&lt;list_reverseiterator object at 0x0000000002BCCEB8&gt;
&gt;&gt;&gt; list(c)
[40, 30, 10, 20]
&gt;&gt;&gt; list(c)
[]
</code></pre></div>
我们打印输出 c 发现提示是：list_reverseiterator。也就是一个迭代对象。同时，我们使用list( c )进行输出，发现只能使用一次。第一次输出了元素，第二次为空。那是因为迭代对象在第一次时已经遍历结束了，第二次不能再使用。<br />
注：关于迭代对象的使用，后续章节会进行详细讲解。</p>
<h3 id="_75">列表相关的其他内置函数汇总<a class="headerlink" href="#_75" title="Permanent link">&para;</a></h3>
<h4 id="max-min">max 和 min<a class="headerlink" href="#max-min" title="Permanent link">&para;</a></h4>
<p>用于返回列表中最大和最小值。
<div class="highlight"><pre><span></span><code>[40, 30, 20, 10]
&gt;&gt;&gt; a = [3,10,20,15,9]
&gt;&gt;&gt; max(a)
20
&gt;&gt;&gt; min(a)
3 
</code></pre></div></p>
<h4 id="sum">sum<a class="headerlink" href="#sum" title="Permanent link">&para;</a></h4>
<p>对数值型列表的所有元素进行求和操作，对非数值型列表运算则会报错。
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = [3,10,20,15,9]
&gt;&gt;&gt; sum(a)
57
</code></pre></div></p>
<h3 id="_76">多维列表<a class="headerlink" href="#_76" title="Permanent link">&para;</a></h3>
<h4 id="_77">二维列表<a class="headerlink" href="#_77" title="Permanent link">&para;</a></h4>
<p>一维列表可以帮助我们存储一维、线性的数据。<br />
二维列表可以帮助我们存储二维、表格的数据。例如下表的数据： </p>
<table>
<thead>
<tr>
<th>姓名</th>
<th>年龄</th>
<th>薪资</th>
<th>城市</th>
</tr>
</thead>
<tbody>
<tr>
<td>高小一</td>
<td>18</td>
<td>30000</td>
<td>北京</td>
</tr>
<tr>
<td>高小二</td>
<td>19</td>
<td>20000</td>
<td>上海</td>
</tr>
<tr>
<td>高小五</td>
<td>20</td>
<td>10000</td>
<td>深圳</td>
</tr>
</tbody>
</table>
<p>源码：
<div class="highlight"><pre><span></span><code>a = [
        [&quot;高小一&quot;,18,30000,&quot;北京&quot;],
        [&quot;高小二&quot;,19,20000,&quot;上海&quot;],
        [&quot;高小一&quot;,20,10000,&quot;深圳&quot;],
    ]
</code></pre></div>
内存结构图：<br />
<img alt="alt text" src="../image-26.png" /><br />
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; print(a[1][0],a[1][1],a[1][2])
高小二 19 20000
</code></pre></div></p>
<p>嵌套循环打印二维列表所有的数据（mypy_08.py）（由于没有学循环，照着敲一遍即可）：
<div class="highlight"><pre><span></span><code>a = [
[&quot;高小一&quot;,18,30000,&quot;北京&quot;],
[&quot;高小二&quot;,19,20000,&quot;上海&quot;],
[&quot;高小一&quot;,20,10000,&quot;深圳&quot;],
]

for m in range(3):
    for n in range(4):
        print(a[m][n],end=&quot;\t&quot;)
    print() #打印完一行，换行
</code></pre></div>
运行结果：
<div class="highlight"><pre><span></span><code>高小一 18 30000 北京
高小二 19 20000 上海
高小一 20 10000 深圳
</code></pre></div></p>
<h3 id="tuple">元组 tuple<a class="headerlink" href="#tuple" title="Permanent link">&para;</a></h3>
<p>列表属于可变序列，可以任意修改列表中的元素。元组属于不可变序列，不能修改元组中的元素。因此，元组没有增加元素、修改元素、删除元素相关的方法。<br />
因此，我们只需要学习元组的创建和删除，元组中元素的访问和计数即可。元组支持如下操作：  </p>
<ol>
<li>索引访问  </li>
<li>切片操作  </li>
<li>连接操作  </li>
<li>成员关系操作  </li>
<li>比较运算操作  </li>
<li>计数：元组长度 len()、最大值 max()、最小值 min()、求和 sum()等。 </li>
</ol>
<h4 id="_78">元组的创建<a class="headerlink" href="#_78" title="Permanent link">&para;</a></h4>
<ol>
<li>
<p>通过()创建元组。小括号可以省略。 <br />
a = (10,20,30) 或者 a = 10,20,30<br />
如果元组只有一个元素，则必须后面加逗号。这是因为解释器会把(1)解释为整数 1，(1,)解释为元组。
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = (1)
&gt;&gt;&gt; type(a)
&lt;class &#39;int&#39;&gt;
&gt;&gt;&gt; a = (1,) #或者 a = 1,
&gt;&gt;&gt; type(a)
&lt;class &#39;tuple&#39;&gt;
</code></pre></div></p>
</li>
<li>
<p>通过 tuple()创建元组 <br />
tuple(可迭代的对象)<br />
例如：<br />
<div class="highlight"><pre><span></span><code>b = tuple() #创建一个空元组对象
b = tuple(&quot;abc&quot;)
b = tuple(range(3))
b = tuple([2,3,4])
</code></pre></div></p>
</li>
</ol>
<p>总结：<br />
tuple()可以接收列表、字符串、其他序列类型、迭代器等生成元组。 <br />
list()可以接收元组、字符串、其他序列类型、迭代器等生成列表。  </p>
<h4 id="_79">元组的元素访问和计数<a class="headerlink" href="#_79" title="Permanent link">&para;</a></h4>
<ol>
<li>
<p>元组的元素不能修改<br />
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = (20,10,30,9,8)
&gt;&gt;&gt; a[3]=33
Traceback (most recent call last):
File &quot;&lt;pyshell#313&gt;&quot;, line 1, in &lt;module&gt;
a[3]=33
TypeError: &#39;tuple&#39; object does not support item assignment
</code></pre></div></p>
</li>
<li>
<p>元组的元素访问和列表一样，只不过返回的仍然是元组对象。
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = (20,10,30,9,8)
&gt;&gt;&gt; a[1]
10
&gt;&gt;&gt; a[1:3]
(10, 30)
&gt;&gt;&gt; a[:4]
(20, 10, 30, 9)
</code></pre></div></p>
</li>
<li>
<p>列表关于排序的方法 list.sorted()是修改原列表对象，元组没有该方法。如果要对元组排序，只能使用内置函数 sorted(tupleObj)，并生成新的列表对象。
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = (20,10,30,9,8)
&gt;&gt;&gt; sorted(a)
[8, 9, 10, 20, 30]
</code></pre></div></p>
</li>
</ol>
<h4 id="zip">zip<a class="headerlink" href="#zip" title="Permanent link">&para;</a></h4>
<p>zip(列表 1，列表 2，...)将多个列表对应位置的元素组合成为元组，并返回这个 zip 对象。
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = [10,20,30]
&gt;&gt;&gt; b = [40,50,60]
&gt;&gt;&gt; c = [70,80,90]
&gt;&gt;&gt; d = zip(a,b,c)
&gt;&gt;&gt; list(d)
[(10, 40, 70), (20, 50, 80), (30, 60, 90)]
</code></pre></div></p>
<h4 id="_80">生成器推导式创建元组<a class="headerlink" href="#_80" title="Permanent link">&para;</a></h4>
<p>从形式上看，生成器推导式与列表推导式类似，只是生成器推导式使用小括号。列表推导式直接生成列表对象，生成器推导式生成的不是列表也不是元组，而是一个生成器对象。 <br />
我们可以通过生成器对象，转化成列表或者元组。也可以使用生成器对象的__next__()方法进行遍历，或者直接作为迭代器对象来使用。不管什么方式使用，元素访问结束后，如果需要重新访问其中的元素，必须重新创建该生成器对象。<br />
【操作】生成器的使用测试 
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; s = (x*2 for x in range(5))
&gt;&gt;&gt; s
&lt;generator object &lt;genexpr&gt; at 0x0000000002BDEB48&gt;
&gt;&gt;&gt; tuple(s)
(0, 2, 4, 6, 8)
&gt;&gt;&gt; list(s) #只能访问一次元素。第二次就为空了。需要再生成一次[]
&gt;&gt;&gt; s
&lt;generator object &lt;genexpr&gt; at 0x0000000002BDEB48&gt;
&gt;&gt;&gt; tuple(s)
()
&gt;&gt;&gt; s = (x*2 for x in range(5))
&gt;&gt;&gt; s.__next__()
0 
&gt;&gt;&gt; s.__next__()
2 
&gt;&gt;&gt; s.__next__()
4
</code></pre></div></p>
<h4 id="_81">元组总结<a class="headerlink" href="#_81" title="Permanent link">&para;</a></h4>
<ol>
<li>元组的核心特点是：不可变序列。</li>
<li>元组的访问和处理速度比列表快。</li>
<li>与整数和字符串一样，元组可以作为字典的键，列表则永远不能作为字典的键使用。</li>
</ol>
<h3 id="_82">字典介绍<a class="headerlink" href="#_82" title="Permanent link">&para;</a></h3>
<p>字典是“键值对”的无序可变序列，字典中的每个元素都是一个“键值对”，包含：“键对象”和“值对象”。可以通过“键对象”实现快速获取、删除、更新对应的“值对象”。<br />
列表中我们通过“下标数字”找到对应的对象。字典中通过“键对象”找到对应的“值对象”。“键”是任意的不可变数据，比如：整数、浮点数、字符串、元组。但是：列表、字典、集合这些可变对象，不能作为“键”。并且“键”不可重复。<br />
“值”可以是任意的数据，并且可重复。<br />
一个典型的字典的定义方式：<br />
<div class="highlight"><pre><span></span><code>a = {&#39;name&#39;:&#39;gaoqi&#39;,&#39;age&#39;:18,&#39;job&#39;:&#39;programmer&#39;}
</code></pre></div></p>
<h3 id="_83">字典的创建<a class="headerlink" href="#_83" title="Permanent link">&para;</a></h3>
<ol>
<li>
<p>我们可以通过{}、dict()来创建字典对象。
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = {&#39;name&#39;:&#39;gaoqi&#39;,&#39;age&#39;:18,&#39;job&#39;:&#39;programmer&#39;}
&gt;&gt;&gt; b = dict(name=&#39;gaoqi&#39;,age=18,job=&#39;programmer&#39;)
&gt;&gt;&gt; a = dict([(&quot;name&quot;,&quot;gaoqi&quot;),(&quot;age&quot;,18)])
&gt;&gt;&gt; c = {} #空的字典对象
&gt;&gt;&gt; d = dict() #空的字典对象
</code></pre></div></p>
</li>
<li>
<p>通过 zip()创建字典对象
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; k = [&#39;name&#39;,&#39;age&#39;,&#39;job&#39;]
&gt;&gt;&gt; v = [&#39;gaoqi&#39;,18,&#39;techer&#39;]
&gt;&gt;&gt; d = dict(zip(k,v))
&gt;&gt;&gt; d
{&#39;name&#39;: &#39;gaoqi&#39;, &#39;age&#39;: 18, &#39;job&#39;: &#39;techer&#39;}
</code></pre></div></p>
</li>
<li>
<p>通过 fromkeys 创建值为空的字典
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = dict.fromkeys([&#39;name&#39;,&#39;age&#39;,&#39;job&#39;])
&gt;&gt;&gt; a
{&#39;name&#39;: None, &#39;age&#39;: None, &#39;job&#39;: None}
</code></pre></div></p>
</li>
</ol>
<h3 id="_84">字典元素的访问<a class="headerlink" href="#_84" title="Permanent link">&para;</a></h3>
<p>为了测试各种访问方法，我们这里设定一个字典对象：<br />
<div class="highlight"><pre><span></span><code>a = {&#39;name&#39;:&#39;gaoqi&#39;,&#39;age&#39;:18,&#39;job&#39;:&#39;programmer&#39;}
</code></pre></div></p>
<ol>
<li>
<p>通过 [键] 获得“值”。若键不存在，则抛出异常。
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = {&#39;name&#39;:&#39;gaoqi&#39;,&#39;age&#39;:18,&#39;job&#39;:&#39;programmer&#39;}
&gt;&gt;&gt; a[&#39;name&#39;]
&#39;gaoqi&#39;
&gt;&gt;&gt; a[&#39;age&#39;]
18
&gt;&gt;&gt; a[&#39;sex&#39;]
Traceback (most recent call last):
File &quot;&lt;pyshell#374&gt;&quot;, line 1, in &lt;module&gt;
a[&#39;sex&#39;]
KeyError: &#39;sex&#39;
</code></pre></div></p>
</li>
<li>
<p>通过 get()方法获得“值”。推荐使用。优点是：指定键不存在，返回 None；也可以设定指定键不存在时默认返回的对象。推荐使用 get()获取“值对象”。
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a.get(&#39;name&#39;)
&#39;gaoqi&#39;
&gt;&gt;&gt; a.get(&#39;sex&#39;)
&gt;&gt;&gt; a.get(&#39;sex&#39;,&#39;一个男人&#39;)
&#39;一个男人&#39;
</code></pre></div></p>
</li>
<li>
<p>列出所有的键值对
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a.items()
dict_items([(&#39;name&#39;, &#39;gaoqi&#39;), (&#39;age&#39;, 18), (&#39;job&#39;, &#39;programmer&#39;)])
</code></pre></div></p>
</li>
<li>
<p>列出所有的键，列出所有的值
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a.keys()
dict_keys([&#39;name&#39;, &#39;age&#39;, &#39;job&#39;])
&gt;&gt;&gt; a.values()
dict_values([&#39;gaoqi&#39;, 18, &#39;programmer&#39;])
</code></pre></div></p>
</li>
<li>
<p>len() 键值对的个数</p>
</li>
<li>
<p>检测一个“键”是否在字典中
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = {&quot;name&quot;:&quot;gaoqi&quot;,&quot;age&quot;:18}
&gt;&gt;&gt; &quot;name&quot; in a
True
</code></pre></div></p>
</li>
</ol>
<h3 id="_85">字典元素添加、修改、删除<a class="headerlink" href="#_85" title="Permanent link">&para;</a></h3>
<ol>
<li>
<p>给字典新增“键值对”。如果“键”已经存在，则覆盖旧的键值对；如果“键”不存在，则新增“键值对”。
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt;a = {&#39;name&#39;:&#39;gaoqi&#39;,&#39;age&#39;:18,&#39;job&#39;:&#39;programmer&#39;}
&gt;&gt;&gt; a[&#39;address&#39;]=&#39;西三旗 1 号院&#39;
&gt;&gt;&gt; a[&#39;age&#39;]=16
&gt;&gt;&gt; a
{&#39;name&#39;: &#39;gaoqi&#39;, &#39;age&#39;: 16, &#39;job&#39;: &#39;programmer&#39;, &#39;address&#39;: &#39;西三旗 1 号院&#39;}
</code></pre></div></p>
</li>
<li>
<p>使用 update()将新字典中所有键值对全部添加到旧字典对象上。如果 key 有重复，则直接覆盖。
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = {&#39;name&#39;:&#39;gaoqi&#39;,&#39;age&#39;:18,&#39;job&#39;:&#39;programmer&#39;}
&gt;&gt;&gt; b = {&#39;name&#39;:&#39;gaoxixi&#39;,&#39;money&#39;:1000,&#39;sex&#39;:&#39;男的&#39;}
&gt;&gt;&gt; a.update(b)
&gt;&gt;&gt; a
{&#39;name&#39;: &#39;gaoxixi&#39;, &#39;age&#39;: 18, &#39;job&#39;: &#39;programmer&#39;, &#39;money&#39;: 1000, &#39;sex&#39;: &#39;男的&#39;}
</code></pre></div></p>
</li>
<li>
<p>字典中元素的删除，可以使用 del()方法；或者 clear()删除所有键值对；pop()删除指定键值对，并返回对应的“值对象”；
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = {&#39;name&#39;:&#39;gaoqi&#39;,&#39;age&#39;:18,&#39;job&#39;:&#39;programmer&#39;}
&gt;&gt;&gt; del(a[&#39;name&#39;])
&gt;&gt;&gt; a
{&#39;age&#39;: 18, &#39;job&#39;: &#39;programmer&#39;}
&gt;&gt;&gt; b = a.pop(&#39;age&#39;)
&gt;&gt;&gt; b
18
</code></pre></div></p>
</li>
<li>
<p>popitem() ：随机删除和返回该键值对。字典是“无序可变序列”，因此没有第一个元素、最后一个元素的概念；popitem 弹出随机的项，因为字典并没有"最后的元素"或者其他有关顺序的概念。若想一个接一个地移除并处理项，这个方法就非常有效（因为不用首先获取键的列表）。
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = {&#39;name&#39;:&#39;gaoqi&#39;,&#39;age&#39;:18,&#39;job&#39;:&#39;programmer&#39;}
&gt;&gt;&gt; a.popitem()
(&#39;job&#39;, &#39;programmer&#39;)
&gt;&gt;&gt; a
{&#39;name&#39;: &#39;gaoqi&#39;, &#39;age&#39;: 18}
&gt;&gt;&gt; a.popitem()
(&#39;age&#39;, 18)
&gt;&gt;&gt; a
{&#39;name&#39;: &#39;gaoqi&#39;}
</code></pre></div></p>
</li>
</ol>
<h3 id="_86">序列解包<a class="headerlink" href="#_86" title="Permanent link">&para;</a></h3>
<p>序列解包可以用于元组、列表、字典。序列解包可以让我们方便的对多个变量赋值。<br />
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; x,y,z=(20,30,10)
&gt;&gt;&gt; x
20
&gt;&gt;&gt; y
30
&gt;&gt;&gt; z
10
&gt;&gt;&gt; (a,b,c)=(9,8,10)
&gt;&gt;&gt; a
9 &gt;
&gt;&gt; [a,b,c]=[10,20,30]
&gt;&gt;&gt; a
10
&gt;&gt;&gt; b
20
</code></pre></div></p>
<p>序列解包用于字典时，默认是对“键”进行操作； 如果需要对键值对操作，则需要使用items()；如果需要对“值”进行操作，则需要使用 values()；
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; s = {&#39;name&#39;:&#39;gaoqi&#39;,&#39;age&#39;:18,&#39;job&#39;:&#39;teacher&#39;}
&gt;&gt;&gt; name,age,job=s #默认对键进行操作
&gt;&gt;&gt; name
&#39;name&#39;
&gt;&gt;&gt; name,age,job=s.items() #对键值对进行操作
&gt;&gt;&gt; name
(&#39;name&#39;, &#39;gaoqi&#39;)
&gt;&gt;&gt; name,age,job=s.values() #对值进行操作
&gt;&gt;&gt; name
&#39;gaoqi&#39;
</code></pre></div></p>
<h3 id="_87">表格数据使用字典和列表存储，并实现访问<a class="headerlink" href="#_87" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>姓名</th>
<th>年龄</th>
<th>薪资</th>
<th>城市</th>
</tr>
</thead>
<tbody>
<tr>
<td>高小一</td>
<td>18</td>
<td>30000</td>
<td>北京</td>
</tr>
<tr>
<td>高小二</td>
<td>19</td>
<td>20000</td>
<td>上海</td>
</tr>
<tr>
<td>高小五</td>
<td>20</td>
<td>10000</td>
<td>深圳</td>
</tr>
</tbody>
</table>
<p>源代码（mypy_09.py）：
<div class="highlight"><pre><span></span><code>r1 = {&quot;name&quot;:&quot;高小一&quot;,&quot;age&quot;:18,&quot;salary&quot;:30000,&quot;city&quot;:&quot;北京&quot;}
r2 = {&quot;name&quot;:&quot;高小二&quot;,&quot;age&quot;:19,&quot;salary&quot;:20000,&quot;city&quot;:&quot;上海&quot;}
r3 = {&quot;name&quot;:&quot;高小五&quot;,&quot;age&quot;:20,&quot;salary&quot;:10000,&quot;city&quot;:&quot;深圳&quot;}

tb = [r1,r2,r3]

#获得第二行的人的薪资
print(tb[1].get(&quot;salary&quot;))

#打印表中所有的的薪资
for i in range(len(tb)): # i --&gt;0,1,2
    print(tb[i].get(&quot;salary&quot;))

#打印表的所有数据
for i in range(len(tb)):
    print(tb[i].get(&quot;name&quot;),tb[i].get(&quot;age&quot;),tb[i].get(&quot;salary&quot;),tb[i].get(&quot;city&quot;))
</code></pre></div></p>
<h2 id="_88">控制语句<a class="headerlink" href="#_88" title="Permanent link">&para;</a></h2>
<p>我们在前面学习的过程中，都是很短的示例代码，没有进行复杂的操作。现在，我们将开始学习流程控制语句。</p>
<p>前面学习的变量、数据类型（整数、浮点数、布尔）、序列（字符串、列表、元组、字典、集合），可以看做是数据的组织方式。数据可以看做是“砖块”！</p>
<p>流程控制语句是代码的组织方式，可以看做是“混凝土”。</p>
<p>一个完整的程序，离不开“砖块”，也离不开“混凝土”。他们的组合，才能让我们建立从小到“一个方法”，大到“操作系统”，这样各种各样的“软件”。</p>
<h3 id="_89">选择结构<a class="headerlink" href="#_89" title="Permanent link">&para;</a></h3>
<p>选择结构通过判断条件是否成立，来决定执行哪个分支。选择结构有多种形式，分为：单分支、双分支、多分支。流程图如下：</p>
<p><img alt="alt text" src="../image-28.png" /></p>
<h4 id="_90">单分支选择结构<a class="headerlink" href="#_90" title="Permanent link">&para;</a></h4>
<p>if 语句单分支结构的语法形式如下：</p>
<p>if 条件表达式:<br />
....语句/语句块</p>
<p>其中：</p>
<ol>
<li>条件表达式：可以是逻辑表达式、关系表达式、算术表达式等等。</li>
<li>语句/语句块：可以是一条语句，也可以是多条语句。多条语句，缩进必须对齐一致。</li>
</ol>
<p>【操作】输入一个数字，小于 10，则打印这个数字(if_test01.py)
<div class="highlight"><pre><span></span><code>num = input(&quot;输入一个数字：&quot;)
if int(num)&lt;10:
    print(num)
</code></pre></div></p>
<h4 id="_91">条件表达式详解<a class="headerlink" href="#_91" title="Permanent link">&para;</a></h4>
<p>在选择和循环结构中，条件表达式的值为 False 的情况如下：  </p>
<p>False、0、0.0、空值 None、空序列对象（空列表、空元祖、空集合、空字典、空字符串）、空 range 对象、空迭代对象。</p>
<p>其他情况，均为 True。这么看来，Python 所有的合法表达式都可以看做条件表达式，甚至包括函数调用的表达式。</p>
<p>【操作】测试各种条件表达式
<div class="highlight"><pre><span></span><code>if 3: #整数作为条件表达式
    print(&quot;ok&quot;)

a = [] #列表作为条件表达式，由于为空列表，是 False
if a:
    print(&quot;空列表，False&quot;)

s = &quot;False&quot; #非空字符串，是 True
if s:
    print(&quot;非空字符串，是 True&quot;)

c = 9
if 3&lt;c&lt;20:
    print(&quot;3&lt;c&lt;20&quot;)

if 3&lt;c and c&lt;20:
    print(&quot;3&lt;c and c&lt;20&quot;)

if True: #布尔值
    print(&quot;True&quot;)
</code></pre></div>
执行结果如下：
<div class="highlight"><pre><span></span><code>ok
非空字符串，是 True
3&lt;c&lt;20
3&lt;c and c&lt;20
True
&gt;&gt;&gt;
</code></pre></div></p>
<p>条件表达式中，不能有赋值操作符“=” </p>
<p>在 Python 中，条件表达式不能出现赋值操作符“=”，避免了其他语言中经常误将关系运算符“==”写作赋值运算符“=”带来的困扰。如下代码将会报语法错误：
<div class="highlight"><pre><span></span><code>if 3&lt;c and (c=20):
    print(&quot;赋值符不能出现在条件表达式中&quot;)
</code></pre></div></p>
<h4 id="_92">双分支选择结构<a class="headerlink" href="#_92" title="Permanent link">&para;</a></h4>
<p>双分支结构的语法格式如下：<br />
if 条件表达式 :<br />
....语句 1/语句块 1<br />
else:<br />
....语句 2/语句块 2 </p>
<p>【操作】输入一个数字，小于 10，则打印该数字；大于 10，则打印“数字太大”
<div class="highlight"><pre><span></span><code>num = input(&quot;输入一个数字：&quot;)
if int(num)&lt;10:
    print(num)
else:
    print(&quot;数字太大&quot;)
</code></pre></div></p>
<h4 id="_93">三元条件运算符<a class="headerlink" href="#_93" title="Permanent link">&para;</a></h4>
<p>Python 提供了三元运算符，用来在某些简单双分支赋值情况。三元条件运算符语法格式如下： <br />
条件为真时的值 if (条件表达式) else 条件为假时的值 <br />
上一个案例代码，可以用三元条件运算符实现： <br />
<div class="highlight"><pre><span></span><code>num = input(&quot;请输入一个数字&quot;)
print( num if int(num)&lt;10 else &quot;数字太大&quot;)
</code></pre></div>
可以看到，这种写法更加简洁，易读。</p>
<h4 id="_94">多分支选择结构<a class="headerlink" href="#_94" title="Permanent link">&para;</a></h4>
<p>多分支选择结构的语法格式如下：   <br />
if 条件表达式 1 :<br />
....语句 1/语句块 1<br />
elif 条件表达式 2:<br />
....语句 2/语句块 2<br />
elif 条件表达式 n : <br />
....语句 n/语句块 n<br />
[else:<br />
....语句 n+1/语句块 n+1<br />
]  </p>
<p>【操作】输入一个学生的成绩，将其转化成简单描述：不及格(小于 60)、及格(60-79)、良好(80-89)、优秀(90-100)。
方法 1（使用完整的条件表达）
<div class="highlight"><pre><span></span><code>score = int(input(&quot;请输入分数&quot;))
grade = &#39;&#39;
if(score&lt;60):
    grade = &quot;不及格&quot;
if(60&lt;=score&lt;80):
    grade = &quot;及格&quot;
if(80&lt;=score&lt;90):
    grade = &quot;良好&quot;
if(90&lt;=score&lt;=100):
    grade = &quot;优秀&quot;
print(&quot;分数是{0},等级是{1}&quot;.format(score,grade))
</code></pre></div>
每个分支都使用了独立的、完整的判断，顺序可以随意挪动，而不影响程序运行。 </p>
<p>方法 2（利用多分支结构）
<div class="highlight"><pre><span></span><code>score = int(input(&quot;请输入分数&quot;))
grade = &#39;&#39;
if score&lt;60 :
    grade = &quot;不及格&quot;
elif score&lt;80 :
    grade = &quot;及格&quot;
elif score&lt;90 :
    grade = &quot;良好&quot;
elif score&lt;=100:
    grade = &quot;优秀&quot;
print(&quot;分数是{0},等级是{1}&quot;.format(score,grade))
</code></pre></div></p>
<p>多分支结构，几个分支之间是有逻辑关系的，不能随意颠倒顺序。</p>
<p>【操作】已知点的坐标(x,y)，判断其所在的象限
<div class="highlight"><pre><span></span><code>x = int(input(&quot;请输入 x 坐标&quot;))
y = int(input(&quot;请输入 y 坐标&quot;))
if(x==0 and y==0):print(&quot;原点&quot;)
elif(x==0):print(&quot;y 轴&quot;)
elif(y==0):print(&quot;x 轴&quot;)
elif(x&gt;0 and y&gt;0):print(&quot;第一象限&quot;)
elif(x&lt;0 and y&gt;0):print(&quot;第二象限&quot;)
elif(x&lt;0 and y&lt;0):print(&quot;第三象限&quot;)
else:
    print(&quot;第四象限&quot;)
</code></pre></div></p>
<h4 id="_95">选择结构嵌套<a class="headerlink" href="#_95" title="Permanent link">&para;</a></h4>
<p>选择结构可以嵌套，使用时一定要注意控制好不同级别代码块的缩进量，因为缩进量决定了代码的从属关系。</p>
<p>【操作】输入一个分数。分数在 0-100 之间。90 以上是 A,80 以上是 B，70 以上是 C，60 以上是 D。60 以下是 E。
<div class="highlight"><pre><span></span><code>score = int(input(&quot;请输入一个在 0-100 之间的数字： &quot;))
grade = &quot;&quot;
if score&gt;100 or score&lt;0:
    score = int(input(&quot;输入错误！ 请重新输入一个在 0-100 之间的数字： &quot;))
else:
    if score&gt;=90:
        grade = &quot;A&quot;
    elif score&gt;=80:
        grade = &#39;B&#39;
    elif score&gt;=70:
        grade = &#39;C&#39;
    elif score&gt;=60:
        grade = &#39;D&#39;
    else:
        grade = &#39;E&#39;
    print(&quot;分数为{0},等级为{1}&quot;.format(score,grade))
</code></pre></div>
或者也可以用下面代码更少的方法。不过，需要大家思考为什么这么写了 
<div class="highlight"><pre><span></span><code>score = int(input(&quot;请输入一个在 0-100 之间的数字： &quot;))
degree = &quot;ABCDE&quot;
num = 0
if score&gt;100 or score&lt;0:
    score = int(input(&quot;输入错误！ 请重新输入一个在 0-100 之间的数字： &quot;))
else:
    num = score//10
    if num&lt;6:num=5
    print(&quot;分数是{0},等级是{1}&quot;.format(score,degree[9-num]))
</code></pre></div></p>
<h3 id="_96">循环结构<a class="headerlink" href="#_96" title="Permanent link">&para;</a></h3>
<p>循环结构用来重复执行一条或多条语句。表达这样的逻辑：如果符合条件，则反复执行循环体里的语句。在每次执行完后都会判断一次条件是否为 True，如果为 True 则重复执行循环体里的语句。</p>
<p>循环体里面的语句至少应该包含改变条件表达式的语句，以使循环趋于结束；否则，就会变成一个死循环。</p>
<h4 id="while">while 循环<a class="headerlink" href="#while" title="Permanent link">&para;</a></h4>
<p>【操作】利用 while 循环打印从 0-10 的数字。
<div class="highlight"><pre><span></span><code>num = 0
while num&lt;=10:
    print(num)
    num += 1
</code></pre></div>
【操作】利用 while 循环，计算 1-100 之间数字的累加和；计算 1-100 之间偶数的累加和，计算 1-100 之间奇数的累加和。
<div class="highlight"><pre><span></span><code>num = 0
sum_all = 0 #1-100 所有数的累加和
sum_even = 0 #1-100 偶数的累加和
sum_odd = 0 #1-100 奇数的累加和
while num&lt;=100:
    sum_all += num
    if num%2==0:sum_even += num
    else:sum_odd += num
    num += 1 #迭代，改变条件表达式，使循环趋于结束

print(&quot;1-100 所有数的累加和&quot;,sum_all)
print(&quot;1-100 偶数的累加和&quot;,sum_even)
print(&quot;1-100 奇数的累加和&quot;,sum_odd)
</code></pre></div></p>
<h4 id="for">for 循环和可迭代对象遍历<a class="headerlink" href="#for" title="Permanent link">&para;</a></h4>
<p>for 循环通常用于可迭代对象的遍历。</p>
<p>【操作】遍历一个元组或列表
<div class="highlight"><pre><span></span><code>for x in (20,30,40):
    print(x*3)
</code></pre></div></p>
<h4 id="_97">可迭代对象<a class="headerlink" href="#_97" title="Permanent link">&para;</a></h4>
<p>Python 包含以下几种可迭代对象：</p>
<ol>
<li>序列。包含：字符串、列表、元组</li>
<li>字典</li>
<li>迭代器对象（iterator）</li>
<li>生成器函数（generator）</li>
<li>文件对象</li>
</ol>
<p>我们已经在前面学习了序列、字典等知识，迭代器对象和生成器函数将在后面进行详解。接下来，我们通过循环来遍历这几种类型的数据：  </p>
<p>【操作】遍历字符串中的字符
<div class="highlight"><pre><span></span><code>for x in &quot;sxt001&quot;:
    print(x)
</code></pre></div>
【操作】遍历字典
<div class="highlight"><pre><span></span><code>d = {&#39;name&#39;:&#39;gaoqi&#39;,&#39;age&#39;:18,&#39;address&#39;:&#39;西三旗 001 号楼&#39;}
for x in d: #遍历字典所有的 key
    print(x)
for x in d.keys():#遍历字典所有的 key
    print(x)
for x in d.values():#遍历字典所有的 value
    print(x)
for x in d.items():#遍历字典所有的&quot;键值对&quot;
    print(x)
</code></pre></div></p>
<h4 id="range_1">range 对象<a class="headerlink" href="#range_1" title="Permanent link">&para;</a></h4>
<p>range 对象是一个迭代器对象，用来产生指定范围的数字序列。格式为： <br />
range(start, end [,step])    </p>
<p>生成的数值序列从 start 开始到 end 结束（不包含 end）。若没有填写 start，则默认从 0开始。step 是可选的步长，默认为 1。如下是几种典型示例：   </p>
<p>for i in range(10) 产生序列：0 1 2 3 4 5 6 7 8 9 <br />
for i in range(3,10) 产生序列：3 4 5 6 7 8 9 <br />
for i in range(3,10,2) 产生序列：3 5 7 9  </p>
<p>【操作】利用 for 循环，计算 1-100 之间数字的累加和；计算 1-100 之间偶数的累加和，计算 1-100 之间奇数的累加和。
<div class="highlight"><pre><span></span><code>sum_all = 0 #1-100 所有数的累加和
sum_even = 0 #1-100 偶数的累加和
sum_odd = 0 #1-100 奇数的累加和
for num in range(101):
    sum_all += num
    if num%2==0:sum_even += num
    else:sum_odd += num
print(&quot;1-100 累加总和{0},奇数和{1},偶数和{2}&quot;.format(sum_all,sum_odd,sum_even))
</code></pre></div></p>
<h4 id="_98">嵌套循环和综合练习<a class="headerlink" href="#_98" title="Permanent link">&para;</a></h4>
<p>一个循环体内可以嵌入另一个循环，一般称为“嵌套循环”，或者“多重循环”。 <br />
【操作】打印如下图案
0 0 0 0 0<br />
1 1 1 1 1<br />
2 2 2 2 2<br />
3 3 3 3 3<br />
4 4 4 4 4<br />
<div class="highlight"><pre><span></span><code>for x in range(5):
    for y in range(5):
        print(x,end=&quot;\t&quot;)
    print() #仅用于换行
</code></pre></div></p>
<p>【操作】利用嵌套循环打印九九乘法表
<div class="highlight"><pre><span></span><code>for m in range(1,10):
    for n in range(1,m+1):
        print(&quot;{0}*{1}={2}&quot;.format(m,n,(m*n)),end=&quot;\t&quot;)
    print()
</code></pre></div>
执行结果：<br />
1*1=1<br />
2*1=2 2*2=4<br />
3*1=3 3*2=6 3*3=9<br />
4*1=4 4*2=8 4*3=12 4*4=16<br />
5*1=5 5*2=10 5*3=15 5*4=20 5*5=25<br />
6*1=6 6*2=12 6*3=18 6*4=24 6*5=30 6*6=36<br />
7*1=7 7*2=14 7*3=21 7*4=28 7*5=35 7*6=42 7*7=49<br />
8*1=8 8*2=16 8*3=24 8*4=32 8*5=40 8*6=48 8*7=56 8*8=64<br />
9*1=9 9*2=18 9*3=27 9*4=36 9*5=45 9*6=54 9*7=63 9*8=72 9*9=81  </p>
<p>【操作】用列表和字典存储下表信息，并打印出表中工资高于 15000 的数据</p>
<table>
<thead>
<tr>
<th>姓名</th>
<th>年龄</th>
<th>薪资</th>
<th>城市</th>
</tr>
</thead>
<tbody>
<tr>
<td>高小一</td>
<td>18</td>
<td>30000</td>
<td>北京</td>
</tr>
<tr>
<td>高小二</td>
<td>19</td>
<td>20000</td>
<td>上海</td>
</tr>
<tr>
<td>高小五</td>
<td>20</td>
<td>10000</td>
<td>深圳</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre><span></span><code>r1= dict(name=&quot;高小一&quot;,age=18,salary=30000,city=&quot;北京&quot;)
r2= dict(name=&quot;高小二&quot;,age=19,salary=20000,city=&quot;上海&quot;)
r3= dict(name=&quot;高小三&quot;,age=20,salary=10000,city=&quot;深圳&quot;)
tb = [r1,r2,r3]

for x in tb:
    if x.get(&quot;salary&quot;)&gt;15000:
        print(x)
</code></pre></div>
<h4 id="break">break 语句<a class="headerlink" href="#break" title="Permanent link">&para;</a></h4>
<p>break 语句可用于 while 和 for 循环，用来结束整个循环。当有嵌套循环时，break 语句只能跳出最近一层的循环。</p>
<p>【操作】使用 break 语句结束循环
<div class="highlight"><pre><span></span><code>while True:
    a = input(&quot;请输入一个字符（输入 Q 或 q 结束）&quot;)
    if a.upper()==&#39;Q&#39;:
        print(&quot;循环结束，退出&quot;)
        break
    else:
        print(a)
</code></pre></div></p>
<h4 id="continue">continue 语句<a class="headerlink" href="#continue" title="Permanent link">&para;</a></h4>
<p>continue 语句用于结束本次循环，继续下一次。多个循环嵌套时，continue 也是应用于最近的一层循环。</p>
<p>【操作】要求输入员工的薪资，若薪资小于 0 则重新输入。最后打印出录入员工的数量和薪资明细，以及平均薪资
<div class="highlight"><pre><span></span><code>empNum = 0
salarySum= 0
salarys = []
while True:
    s = input(&quot;请输入员工的薪资（按 Q 或 q 结束）&quot;)

    if s.upper()==&#39;Q&#39;:
        print(&quot;录入完成，退出&quot;)
        break
    if float(s)&lt;0:
        continue
    empNum +=1
    salarys.append(float(s))
    salarySum += float(s)

print(&quot;员工数{0}&quot;.format(empNum))
print(&quot;录入薪资：&quot;,salarys)
print(&quot;平均薪资{0}&quot;.format(salarySum/empNum))
</code></pre></div>
执行结果：<br />
请输入员工的薪资（按 Q 或 q 结束）2000<br />
请输入员工的薪资（按 Q 或 q 结束）3000<br />
请输入员工的薪资（按 Q 或 q 结束）4000<br />
请输入员工的薪资（按 Q 或 q 结束）5000<br />
请输入员工的薪资（按 Q 或 q 结束）Q<br />
录入完成，退出<br />
员工数 4<br />
录入薪资： [2000.0, 3000.0, 4000.0, 5000.0]<br />
平均薪资 3500.0  </p>
<h4 id="else">else 语句<a class="headerlink" href="#else" title="Permanent link">&para;</a></h4>
<p>while、for 循环可以附带一个 else 语句（可选）。如果 for、while 语句没有被 break 语句结束，则会执行 else 子句，否则不执行。</p>
<p>【操作】员工一共 4 人。录入这 4 位员工的薪资。全部录入后，打印提示“您已经全部录入 4 名员工的薪资”。最后，打印输出录入的薪资和平均薪资
<div class="highlight"><pre><span></span><code>salarySum= 0
salarys = []

for i in range(4):
    s = input(&quot;请输入一共 4 名员工的薪资（按 Q 或 q 中途结束）&quot;)
    if s.upper()==&#39;Q&#39;:
        print(&quot;录入完成，退出&quot;)
        break
    if float(s)&lt;0:
        continue

    salarys.append(float(s))
    salarySum += float(s)
else:
    print(&quot;您已经全部录入 4 名员工的薪资&quot;)

print(&quot;录入薪资：&quot;,salarys)
print(&quot;平均薪资{0}&quot;.format(salarySum/4))
</code></pre></div></p>
<h4 id="_99">循环代码优化<a class="headerlink" href="#_99" title="Permanent link">&para;</a></h4>
<p>虽然计算机越来越快，空间也越来越大，我们仍然要在性能问题上“斤斤计较”。编写循环时，遵守下面三个原则可以大大提高运行效率，避免不必要的低效计算：</p>
<ol>
<li>尽量减少循环内部不必要的计算</li>
<li>嵌套循环中，尽量减少内层循环的计算，尽可能向外提。</li>
<li>局部变量查询较快，尽量使用局部变量</li>
</ol>
<div class="highlight"><pre><span></span><code>#循环代码优化测试
import time

start = time.time()
for i in range(1000):
    result = []
    for m in range(10000):
        result.append(i*1000+m*100)

end = time.time()
print(&quot;耗时： {0}&quot;.format((end-start)))

start2 = time.time()
for i in range(1000):
    result = []
    c = i*1000
    for m in range(10000):
        result.append(c+m*100)
end2 = time.time()
print(&quot;耗时： {0}&quot;.format((end2-start2)))
</code></pre></div>
<h4 id="_100">其他优化手段<a class="headerlink" href="#_100" title="Permanent link">&para;</a></h4>
<ol>
<li>连接多个字符串， 使用 join()而不使用+</li>
<li>列表进行元素插入和删除， 尽量在列表尾部操作</li>
</ol>
<h3 id="zip_1">使用 zip()并行迭代<a class="headerlink" href="#zip_1" title="Permanent link">&para;</a></h3>
<p>我们可以通过 zip()函数对多个序列进行并行迭代，zip()函数在最短序列“用完”时就会停止。</p>
<p>【操作】测试 zip()并行迭代
<div class="highlight"><pre><span></span><code>names = (&quot;高淇&quot;,&quot;高老二&quot;,&quot;高老三&quot;,&quot;高老四&quot;)
ages = (18,16,20,25)
jobs = (&quot;老师&quot;,&quot;程序员&quot;,&quot;公务员&quot;)

for name,age,job in zip(names,ages,jobs):
    print(&quot;{0}--{1}--{2}&quot;.format(name,age,job))
</code></pre></div>
执行结果：<br />
高淇--18--老师<br />
高老二--16--程序员<br />
高老三--20--公务员  </p>
<h3 id="_101">推导式创建序列<a class="headerlink" href="#_101" title="Permanent link">&para;</a></h3>
<p>推导式是从一个或者多个迭代器快速创建序列的一种方法。它可以将循环和条件判断结合，从而避免冗长的代码。推导式是典型的 Python 风格，会使用它代表你已经超过 Python 初学者的水平。</p>
<h4 id="_102">列表推导式<a class="headerlink" href="#_102" title="Permanent link">&para;</a></h4>
<p>列表推导式生成列表对象，语法如下：<br />
[表达式 for item in 可迭代对象 ]<br />
或者：{表达式 for item in 可迭代对象 if 条件判断}<br />
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; [x for x in range(1,5)]
[1, 2, 3, 4]
&gt;&gt;&gt; [x*2 for x in range(1,5)]
[2, 4, 6, 8]
&gt;&gt;&gt; [x*2 for x in range(1,20) if x%5==0 ]
[10, 20, 30]
&gt;&gt;&gt; [a for a in &quot;abcdefg&quot;]
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]
&gt;&gt;&gt; cells = [(row,col) for row in range(1,10) for col in range(1,10)] #可以使用两个循环
&gt;&gt;&gt; for cell in cells:
print(cell)
</code></pre></div></p>
<h4 id="_103">字典推导式<a class="headerlink" href="#_103" title="Permanent link">&para;</a></h4>
<p>字典的推导式生成字典对象，格式如下：<br />
{key_expression : value_expression for 表达式 in 可迭代对象}<br />
类似于列表推导式，字典推导也可以增加 if 条件判断、多个 for 循环。  </p>
<p>统计文本中字符出现的次数：
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; my_text = &#39; i love you, i love sxt, i love gaoqi&#39;
&gt;&gt;&gt; char_count = {c:my_text.count(c) for c in my_text}
&gt;&gt;&gt; char_count
{&#39; &#39;: 9, &#39;i&#39;: 4, &#39;l&#39;: 3, &#39;o&#39;: 5, &#39;v&#39;: 3, &#39;e&#39;: 3, &#39;y&#39;: 1, &#39;u&#39;: 1, &#39;,&#39;: 2, &#39;s&#39;: 1, &#39;x&#39;: 1, &#39;t&#39;: 1, &#39;g&#39;: 1, &#39;a&#39;: 1, &#39;q&#39;: 1}
</code></pre></div></p>
<h4 id="_104">集合推导式<a class="headerlink" href="#_104" title="Permanent link">&para;</a></h4>
<p>集合推导式生成集合，和列表推导式的语法格式类似：<br />
{表达式 for item in 可迭代对象 }<br />
或者：{表达式 for item in 可迭代对象 if 条件判断}<br />
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; {x for x in range(1,100) if x%9==0}
{99, 36, 72, 9, 45, 81, 18, 54, 90, 27, 63}
</code></pre></div></p>
<h4 id="_105">生成器推导式（生成元组）<a class="headerlink" href="#_105" title="Permanent link">&para;</a></h4>
<p>很多同学可能会问：“都有推导式，元组有没有？”，能不能用小括号呢？
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; (x for x in range(1,100) if x%9==0)
&lt;generator object &lt;genexpr&gt; at 0x0000000002BD3048&gt;
</code></pre></div>
我们发现提示的是“一个生成器对象”。显然，元组是没有推导式的。</p>
<p>一个生成器只能运行一次。第一次迭代可以得到数据，第二次迭代发现数据已经没有了。
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; gnt = (x for x in range(1,100) if x%9==0)
&gt;&gt;&gt; for x in gnt:
    print(x,end=&#39; &#39;)
9 18 27 36 45 54 63 72 81 90 99
&gt;&gt;&gt; for x in gnt:
    print(x,end=&#39; &#39;)
&gt;&gt;&gt;
</code></pre></div></p>
<h2 id="_106">函数用法和底层分析<a class="headerlink" href="#_106" title="Permanent link">&para;</a></h2>
<p>函数是可重用的程序代码块。函数的作用，不仅可以实现代码的复用，更能实现代码的一致性。一致性指的是，只要修改函数的代码，则所有调用该函数的地方都能得到体现。</p>
<p>在编写函数时，函数体中的代码写法和我们前面讲述的基本一致，只是对代码实现了封装，并增加了函数调用、传递参数、返回计算结果等内容。</p>
<p>为了让大家更容易理解，掌握的更深刻。我们也要深入内存底层进行分析。绝大多数语言内存底层都是高度相似的，这样大家掌握了这些内容也便于以后学习其他语言。</p>
<h3 id="_107">函数简介<a class="headerlink" href="#_107" title="Permanent link">&para;</a></h3>
<h4 id="_108">函数的基本概念<a class="headerlink" href="#_108" title="Permanent link">&para;</a></h4>
<ol>
<li>一个程序由一个个任务组成；函数就是代表一个任务或者一个功能。</li>
<li>函数是代码复用的通用机制。</li>
</ol>
<h4 id="python_9">Python 函数的分类<a class="headerlink" href="#python_9" title="Permanent link">&para;</a></h4>
<p>Python 中函数分为如下几类：  </p>
<ol>
<li>内置函数<br />
我们前面使用的 str()、list()、len()等这些都是内置函数，我们可以拿来直接使用。  </li>
<li>标准库函数<br />
我们可以通过 import 语句导入库，然后使用其中定义的函数  </li>
<li>第三方库函数<br />
Python 社区也提供了很多高质量的库。下载安装这些库后，也是通过 import 语句导入，然后可以使用这些第三方库的函数</li>
<li>用户自定义函数<br />
用户自己定义的函数，显然也是开发中适应用户自身需求定义的函数。今天我们学习的就是如何自定义函数。</li>
</ol>
<h3 id="_109">函数的定义和调用<a class="headerlink" href="#_109" title="Permanent link">&para;</a></h3>
<h4 id="_110">核心要点<a class="headerlink" href="#_110" title="Permanent link">&para;</a></h4>
<p>Python 中，定义函数的语法如下：  </p>
<p>def 函数名 ([参数列表]) :<br />
....'''文档字符串'''<br />
....函数体/若干语句  </p>
<p>要点：</p>
<ol>
<li>我们使用 def 来定义函数，然后就是一个空格和函数名称；<ul>
<li>Python 执行 def 时，会创建一个函数对象，并绑定到函数名变量上。</li>
</ul>
</li>
<li>参数列表<ul>
<li>圆括号内是形式参数列表，有多个参数则使用逗号隔开</li>
<li>形式参数不需要声明类型，也不需要指定函数返回值类型</li>
<li>无参数，也必须保留空的圆括号</li>
<li>实参列表必须与形参列表一一对应</li>
</ul>
</li>
<li>return 返回值<ul>
<li>如果函数体中包含 return 语句，则结束函数执行并返回值；</li>
<li>如果函数体中不包含 return 语句，则返回 None 值。</li>
</ul>
</li>
<li>调用函数之前，必须要先定义函数，即先调用 def 创建函数对象<ul>
<li>内置函数对象会自动创建</li>
<li>标准库和第三方库函数，通过 import 导入模块时，会执行模块中的 def 语句</li>
</ul>
</li>
</ol>
<h4 id="_111">形参和实参<a class="headerlink" href="#_111" title="Permanent link">&para;</a></h4>
<p>【操作】定义一个函数，实现两个数的比较，并返回较大的值。
<div class="highlight"><pre><span></span><code>def printMax(a,b):
    &#39;&#39;&#39;实现两个数的比较，并返回较大的值&#39;&#39;&#39;
    if a&gt;b:
        print(a,&#39;较大值&#39;)
    else:
        print(b,&#39;较大值&#39;)

printMax(10,20)
printMax(30,5)
</code></pre></div>
执行结果：
<div class="highlight"><pre><span></span><code>20 较大值
30 较大值
</code></pre></div></p>
<p>上面的 printMax 函数中，在定义时写的 printMax(a,b)。a 和 b 称为“形式参数”，简称“形参”。也就是说，形式参数是在定义函数时使用的。 形式参数的命名只要符合“标识符”命名规则即可。</p>
<p>在调用函数时，传递的参数称为“实际参数”，简称“实参”。上面代码中，printMax(10,20)，10 和 20 就是实际参数。</p>
<h4 id="_112">文档字符串(函数的注释)<a class="headerlink" href="#_112" title="Permanent link">&para;</a></h4>
<p>程序的可读性最重要，一般建议在函数体开始的部分附上函数定义说明，这就是“文档字符串”，也有人成为“函数的注释”。我们通过三个单引号或者三个双引号来实现，中间可以加入多行文字进行说明。</p>
<p>【操作】测试文档字符串的使用
<div class="highlight"><pre><span></span><code>def print_star(n):
    &#39;&#39;&#39;根据传入的 n，打印多个星号&#39;&#39;&#39;
    print(&quot;*&quot;*n)

help(print_star)
</code></pre></div>
我们调用 help(函数名.<strong>doc</strong>)可以打印输出函数的文档字符串。执行结果如下：
<div class="highlight"><pre><span></span><code>Help on function print_star in module __main__:

print_star(n)
    根据传入的 n，打印多个星号
</code></pre></div></p>
<h4 id="_113">返回值<a class="headerlink" href="#_113" title="Permanent link">&para;</a></h4>
<p>return 返回值要点：</p>
<ol>
<li>如果函数体中包含 return 语句，则结束函数执行并返回值；</li>
<li>如果函数体中不包含 return 语句，则返回 None 值。</li>
<li>要返回多个返回值，使用列表、元组、字典、集合将多个值“存起来”即可。</li>
</ol>
<p>【操作】定义一个打印 n 个星号的无返回值的函数
<div class="highlight"><pre><span></span><code>def print_star(n):
    print(&quot;*&quot;*n)

print_star(5)
</code></pre></div></p>
<p>【操作】定义一个返回两个数平均值的函数
<div class="highlight"><pre><span></span><code>def my_avg(a,b):
    return (a+b)/2

#如下是函数的调用
c = my_avg(20,30)
print(c)
</code></pre></div></p>
<h3 id="_114">函数也是对象，内存底层分析<a class="headerlink" href="#_114" title="Permanent link">&para;</a></h3>
<p>Python 中，“一切都是对象”。实际上，执行 def 定义函数后，系统就创建了相应的函数对象。我们执行如下程序，然后进行解释：
<div class="highlight"><pre><span></span><code>def print_star(n):
    print(&quot;*&quot;*n)

print(print_star)
print(id(print_star))
c = print_star
c(3)
</code></pre></div>
执行结果：
<div class="highlight"><pre><span></span><code>&lt;function print_star at 0x0000000002BB8620&gt;
45844000
***
</code></pre></div>
上面代码执行 def 时，系统中会创建函数对象，并通过 print_star 这个变量进行引用：</p>
<p><img alt="alt text" src="../image-29.png" /></p>
<p>我们执行“c=print_star”后，显然将 print_star 变量的值赋给了变量 c，内存图变成了：</p>
<p><img alt="alt text" src="../image-30.png" /></p>
<p>显然，我们可以看出变量 c 和 print_star 都是指向了同一个函数对象。因此，执行 c(3)和执行 print_star(3)的效果是完全一致的。 Python 中，圆括号意味着调用函数。在没有圆括号的情况下，Python 会把函数当做普通对象。</p>
<p>与此核心原理类似，我们也可以做如下操作：
<div class="highlight"><pre><span></span><code>zhengshu = int
zhengshu(&quot;234&quot;)
</code></pre></div>
显然，我们将内置函数对象 int() 赋值给了变量 zhengshu，这样 zhengshu 和 int 都是指向了同一个内置函数对象。当然，此处仅限于原理性讲解，实际开发中没必要这么做。</p>
<h3 id="_115">变量的作用域<a class="headerlink" href="#_115" title="Permanent link">&para;</a></h3>
<p>变量起作用的范围称为变量的作用域，不同作用域内同名变量之间互不影响。变量分为：全局变量、局部变量。</p>
<p>全局变量：</p>
<ol>
<li>在函数和类定义之外声明的变量。作用域为定义的模块，从定义位置开始直到模块结束。 </li>
<li>全局变量降低了函数的通用性和可读性。应尽量避免全局变量的使用。 </li>
<li>全局变量一般做常量使用。 </li>
<li>函数内要改变全局变量的值，使用 global 声明一下。</li>
</ol>
<p>局部变量：</p>
<ol>
<li>在函数体中（包含形式参数）声明的变量。</li>
<li>局部变量的引用比全局变量快，优先考虑使用。</li>
<li>如果局部变量和全局变量同名，则在函数内隐藏全局变量，只使用同名的局部变量</li>
</ol>
<p>【操作】全局变量的作用域测试
<div class="highlight"><pre><span></span><code>a = 100 #全局变量
def f1():
    global a #如果要在函数内改变全局变量的值，增加 global 关键字声明
    print(a) #打印全局变量 a 的值
    a = 300

f1()
print(a)
</code></pre></div>
执行结果：
<div class="highlight"><pre><span></span><code>100
300
</code></pre></div>
【操作】全局变量和局部变量同名测试
<div class="highlight"><pre><span></span><code>a=100
def f1():
    a = 3 #同名的局部变量
    print(a)

f1()
print(a) #a 仍然是 100，没有变化
</code></pre></div>
执行结果：
<div class="highlight"><pre><span></span><code>3 
100
</code></pre></div>
【操作】 输出局部变量和全局变量
<div class="highlight"><pre><span></span><code>a = 100

def f1(a,b,c):
    print(a,b,c)
    print(locals()) #打印输出的局部变量
    print(&quot;#&quot;*20)
    print(globals()) #打印输出的全局变量

f1(2,3,4)
</code></pre></div>
执行结果：
<div class="highlight"><pre><span></span><code>2 3 4
{&#39;c&#39;: 4, &#39;b&#39;: 3, &#39;a&#39;: 2}
####################
{&#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None, &#39;__package__&#39;: None, &#39;__loader__&#39;: &lt;class
&#39;_frozen_importlib.BuiltinImporter&#39;&gt;, &#39;__spec__&#39;: None, &#39;__annotations__&#39;: {},
&#39;__builtins__&#39;: &lt;module &#39;builtins&#39; (built-in)&gt;, &#39;__file__&#39;: &#39;E:\\PythonExec\\if_test01.py&#39;,
&#39;a&#39;: 100, &#39;f1&#39;: &lt;function f1 at 0x0000000002BB8620&gt;}
</code></pre></div></p>
<h3 id="_116">局部变量和全局变量效率测试<a class="headerlink" href="#_116" title="Permanent link">&para;</a></h3>
<p>局部变量的查询和访问速度比全局变量快，优先考虑使用，尤其是在循环的时候。<br />
在特别强调效率的地方或者循环次数较多的地方，可以通过将全局变量转为局部变量提高运行速度。  <br />
【操作】测试局部变量和全局变量效率
<div class="highlight"><pre><span></span><code>#测试局部变量、 全局变量的效率
import math
import time

def test01():
    start = time.time()
    for i in range(10000000):
        math.sqrt(30)
    end = time.time()
    print(&quot;耗时{0}&quot;.format((end-start)))

def test02():
    b = math.sqrt
    start = time.time()
    for i in range(10000000):
        b(30)
    end = time.time()
    print(&quot;耗时{0}&quot;.format((end-start)))

test01()
test02()
</code></pre></div>
运行结果：
<div class="highlight"><pre><span></span><code>耗时 2.3589999675750732
耗时 1.6410000324249268
</code></pre></div></p>
<h3 id="_117">参数的传递<a class="headerlink" href="#_117" title="Permanent link">&para;</a></h3>
<p>函数的参数传递本质上就是：从实参到形参的赋值操作。 Python 中“一切皆对象”，所有的赋值操作都是“引用的赋值”。所以，Python 中参数的传递都是“引用传递”，不是“值传递”。具体操作时分为两类：</p>
<ol>
<li>对“可变对象”进行“写操作”，直接作用于原对象本身。</li>
<li>对“不可变对象”进行“写操作”，会产生一个新的“对象空间”，并用新的值填充这块空间。（起到其他语言的“值传递”效果，但不是“值传递”）</li>
</ol>
<p>可变对象有：<br />
字典、列表、集合、自定义的对象等<br />
不可变对象有：<br />
数字、字符串、元组、function 等  </p>
<h4 id="_118">传递可变对象的引用<a class="headerlink" href="#_118" title="Permanent link">&para;</a></h4>
<p>传递参数是可变对象（例如：列表、字典、自定义的其他可变对象等），实际传递的还是对象的引用。在函数体中不创建新的对象拷贝，而是可以直接修改所传递的对象。 <br />
【操作】参数传递：传递可变对象的引用
<div class="highlight"><pre><span></span><code>b = [10,20]
def f2(m):
    print(&quot;m:&quot;,id(m)) #b 和 m 是同一个对象
    m.append(30) #由于 m 是可变对象，不创建对象拷贝，直接修改这个对象

f2(b)
print(&quot;b:&quot;,id(b))
print(b)
</code></pre></div>
执行结果：
<div class="highlight"><pre><span></span><code>m: 45765960
b: 45765960
[10, 20, 30]
</code></pre></div></p>
<h4 id="_119">传递不可变对象的引用<a class="headerlink" href="#_119" title="Permanent link">&para;</a></h4>
<p>传递参数是不可变对象（例如：int、float、字符串、元组、布尔值），实际传递的还是对象的引用。在”赋值操作”时，由于不可变对象无法修改，系统会新创建一个对象。<br />
【操作】参数传递：传递不可变对象的引用
<div class="highlight"><pre><span></span><code>a = 100
def f1(n):
    print(&quot;n:&quot;,id(n)) #传递进来的是 a 对象的地址
    n = n+200 #由于 a 是不可变对象，因此创建新的对象 n
    print(&quot;n:&quot;,id(n)) #n 已经变成了新的对象
    print(n)

f1(a)
print(&quot;a:&quot;,id(a))
</code></pre></div>
执行结果：
<div class="highlight"><pre><span></span><code>n: 1663816464
n: 46608592
300
a: 1663816464
</code></pre></div>
显然，通过 id 值我们可以看到 n 和 a 一开始是同一个对象。给 n 赋值后，n 是新的对象。</p>
<h4 id="_120">浅拷贝和深拷贝<a class="headerlink" href="#_120" title="Permanent link">&para;</a></h4>
<p>为了更深入的了解参数传递的底层原理，我们需要讲解一下“浅拷贝和深拷贝”。我们可以使用内置函数：copy(浅拷贝)、deepcopy(深拷贝)。 <br />
浅拷贝：不拷贝子对象的内容，只是拷贝子对象的引用。<br />
深拷贝：会连子对象的内存也全部拷贝一份，对子对象的修改不会影响源对象。 <br />
源码：
<div class="highlight"><pre><span></span><code>#测试浅拷贝和深拷贝
import copy

def testCopy():
    &#39;&#39;&#39;测试浅拷贝&#39;&#39;&#39;
    a = [10, 20, [5, 6]]
    b = copy.copy(a)

    print(&quot;a&quot;, a)
    print(&quot;b&quot;, b)
    b.append(30)
    b[2].append(7)
    print(&quot;浅拷贝......&quot;)
    print(&quot;a&quot;, a)
    print(&quot;b&quot;, b)

def testDeepCopy():
    &#39;&#39;&#39;测试深拷贝&#39;&#39;&#39;
    a = [10, 20, [5, 6]]
    b = copy.deepcopy(a)
    print(&quot;a&quot;, a)
    print(&quot;b&quot;, b)
    b.append(30)
    b[2].append(7)
    print(&quot;深拷贝......&quot;)
    print(&quot;a&quot;, a)
    print(&quot;b&quot;, b)

testCopy()
print(&quot;*************&quot;)
testDeepCopy()
</code></pre></div>
运行结果：
<div class="highlight"><pre><span></span><code>a [10, 20, [5, 6]]
b [10, 20, [5, 6]]
浅拷贝......
a [10, 20, [5, 6, 7]]
b [10, 20, [5, 6, 7], 30]
*************
a [10, 20, [5, 6]]
b [10, 20, [5, 6]]
深拷贝......
a [10, 20, [5, 6]]
b [10, 20, [5, 6, 7], 30]
</code></pre></div></p>
<h4 id="_121">传递不可变对象包含的子对象是可变的情况<a class="headerlink" href="#_121" title="Permanent link">&para;</a></h4>
<p><div class="highlight"><pre><span></span><code>#传递不可变对象时。 不可变对象里面包含的子对象是可变的。 则方法内修改了这个可变对象， 源对象也发生了变化。
a = (10,20,[5,6])
print(&quot;a:&quot;,id(a))

def test01(m):
    print(&quot;m:&quot;,id(m))
    m[2][0] = 888
    print(m)
    print(&quot;m:&quot;,id(m))

test01(a)
print(a)
</code></pre></div>
运行结果：
<div class="highlight"><pre><span></span><code>a: 41611632
m: 41611632
(10, 20, [888, 6])
m: 41611632
(10, 20, [888, 6])
</code></pre></div></p>
<h3 id="_122">参数的几种类型<a class="headerlink" href="#_122" title="Permanent link">&para;</a></h3>
<h4 id="_123">位置参数<a class="headerlink" href="#_123" title="Permanent link">&para;</a></h4>
<p>函数调用时，实参默认按位置顺序传递，需要个数和形参匹配。按位置传递的参数，称为：“位置参数”。<br />
【操作】测试位置参数
<div class="highlight"><pre><span></span><code>def f1(a,b,c):
    print(a,b,c)

f1(2,3,4)
f1(2,3) #报错，位置参数不匹配
</code></pre></div>
执行结果：
<div class="highlight"><pre><span></span><code>2 3 4
Traceback (most recent call last):
File &quot;E:\PythonExec\if_test01.py&quot;, line 5, in &lt;module&gt;
f1(2,3)
TypeError: f1() missing 1 required positional argument: &#39;c&#39;
</code></pre></div></p>
<h4 id="_124">默认值参数<a class="headerlink" href="#_124" title="Permanent link">&para;</a></h4>
<p>我们可以为某些参数设置默认值，这样这些参数在传递时就是可选的。称为“默认值参数”。默认值参数放到位置参数后面。 <br />
【操作】测试默认值参数
<div class="highlight"><pre><span></span><code>def f1(a,b,c=10,d=20): #默认值参数必须位于普通位置参数后面
    print(a,b,c,d)

f1(8,9)
f1(8,9,19)
f1(8,9,19,29)
</code></pre></div>
执行结果：
<div class="highlight"><pre><span></span><code>8 9 10 20
8 9 19 20
8 9 19 29
</code></pre></div></p>
<h4 id="_125">命名参数<a class="headerlink" href="#_125" title="Permanent link">&para;</a></h4>
<p>我们也可以按照形参的名称传递参数，称为“命名参数”，也称“关键字参数”。<br />
【操作】测试命名参数
<div class="highlight"><pre><span></span><code>def f1(a,b,c):
    print(a,b,c)

f1(8,9,19) #位置参数
f1(c=10,a=20,b=30) #命名参数
</code></pre></div>
执行结果：
<div class="highlight"><pre><span></span><code>8 9 19
20 30 10
</code></pre></div></p>
<h4 id="_126">可变参数<a class="headerlink" href="#_126" title="Permanent link">&para;</a></h4>
<p>可变参数指的是“可变数量的参数”。分两种情况： </p>
<ol>
<li>*param（一个星号），将多个参数收集到一个“元组”对象中。</li>
<li>**param（两个星号），将多个参数收集到一个“字典”对象中。</li>
</ol>
<p>【操作】测试可变参数处理（元组、字典两种方式）
<div class="highlight"><pre><span></span><code>def f1(a,b,*c):
    print(a,b,c)

f1(8,9,19,20)

def f2(a,b,**c):
    print(a,b,c)

f2(8,9,name=&#39;gaoqi&#39;,age=18)

def f3(a,b,*c,**d):
    print(a,b,c,d)

f3(8,9,20,30,name=&#39;gaoqi&#39;,age=18)
</code></pre></div>
执行结果：
<div class="highlight"><pre><span></span><code>8 9 (19, 20)
8 9 {&#39;name&#39;: &#39;gaoqi&#39;, &#39;age&#39;: 18}
8 9 (20, 30) {&#39;name&#39;: &#39;gaoqi&#39;, &#39;age&#39;: 18}
</code></pre></div></p>
<h4 id="_127">强制命名参数<a class="headerlink" href="#_127" title="Permanent link">&para;</a></h4>
<p>在带星号的“可变参数”后面增加新的参数，必须在调用的时候“强制命名参数”。 <br />
【操作】强制命名参数的使用
<div class="highlight"><pre><span></span><code>def f1(*a,b,c):
    print(a,b,c)

#f1(2,3,4) #会报错。由于 a 是可变参数，将 2,3,4 全部收集。造成 b 和 c 没有赋值。
f1(2,b=3,c=4)
</code></pre></div>
执行结果：
<div class="highlight"><pre><span></span><code>(2,) 3 4
</code></pre></div></p>
<h3 id="lambda">lambda 表达式和匿名函数<a class="headerlink" href="#lambda" title="Permanent link">&para;</a></h3>
<p>lambda 表达式可以用来声明匿名函数。lambda 函数是一种简单的、在同一行中定义函数的方法。lambda 函数实际生成了一个函数对象。</p>
<p>lambda 表达式只允许包含一个表达式，不能包含复杂语句，该表达式的计算结果就是函数的返回值。</p>
<p>lambda 表达式的基本语法如下： <br />
lambda arg1,arg2,arg3... : &lt;表达式&gt;  <br />
arg1/arg2/arg3 为函数的参数。&lt;表达式&gt;相当于函数体。运算结果是：表达式的运算结果。    </p>
<p>【操作】lambda 表达式使用
<div class="highlight"><pre><span></span><code>f = lambda a,b,c:a+b+c
print(f)
print(f(2,3,4))
g = [lambda a:a*2,lambda b:b*3,lambda c:c*4]
print(g[0](6),g[1](7),g[2](8))
</code></pre></div>
执行结果：
<div class="highlight"><pre><span></span><code>&lt;function &lt;lambda&gt; at 0x0000000002BB8620&gt;
9 1
2 21 32
</code></pre></div></p>
<h3 id="eval">eval()函数<a class="headerlink" href="#eval" title="Permanent link">&para;</a></h3>
<p>功能：将字符串 str 当成有效的表达式来求值并返回计算结果。<br />
语法： eval(source[, globals[, locals]]) -&gt; value<br />
参数：<br />
source：一个 Python 表达式或函数 compile()返回的代码对象<br />
globals：可选。必须是 dictionary<br />
locals：可选。任意映射对象 <br />
<div class="highlight"><pre><span></span><code>#测试 eval()函数
s = &quot;print(&#39;abcde&#39;)&quot;
eval(s)

a = 10
b = 20
c = eval(&quot;a+b&quot;)
print(c)

dict1 = dict(a=100,b=200)
d = eval(&quot;a+b&quot;,dict1)
print(d)
</code></pre></div>
eval 函数会将字符串当做语句来执行， 因此会被注入安全隐患。 比如： 字符串中含有删除文件的语句。 那就麻烦大了。 因此， 使用时候， 要慎重！ ！ ！</p>
<h3 id="_128">递归函数<a class="headerlink" href="#_128" title="Permanent link">&para;</a></h3>
<p>递归函数指的是：自己调用自己的函数，在函数体内部直接或间接的自己调用自己。递归类似于大家中学数学学习过的“数学归纳法”。 每个递归函数必须包含两个部分：</p>
<ol>
<li>终止条件<br />
表示递归什么时候结束。一般用于返回值，不再调用自己。</li>
<li>递归步骤<br />
把第 n 步的值和第 n-1 步相关联。</li>
</ol>
<p>递归函数由于会创建大量的函数对象、过量的消耗内存和运算能力。在处理大量数据时，谨慎使用。</p>
<p>【操作】 使用递归函数计算阶乘(factorial)
<div class="highlight"><pre><span></span><code>def factorial(n):
    if n==1:return 1
    return n*factorial(n-1)

for i in range(1,6):
    print(i,&#39;!=&#39;,factorial(i))
</code></pre></div>
执行结果：
<div class="highlight"><pre><span></span><code>1 != 1
2 != 2
3 != 6
4 != 24
5！=120
</code></pre></div></p>
<h3 id="nonlocal">nonlocal 关键字<a class="headerlink" href="#nonlocal" title="Permanent link">&para;</a></h3>
<p>nonlocal 用来声明外层的局部变量。 <br />
global 用来声明全局变量。    </p>
<p>【操作】 使用 nonlocal 声明外层局部变量
<div class="highlight"><pre><span></span><code>#测试 nonlocal、 global 关键字的用法
a = 100

def outer():
    b = 10

    def inner():
        nonlocal b #声明外部函数的局部变量
        print(&quot;inner b:&quot;,b)
        b = 20

        global a #声明全局变量
        a = 1000

    inner()
    print(&quot;outer b:&quot;,b)

outer()
print(&quot;a： &quot;,a)
</code></pre></div></p>
<h3 id="legb">LEGB 规则<a class="headerlink" href="#legb" title="Permanent link">&para;</a></h3>
<p>Python 在查找“名称”时，是按照 LEGB 规则查找的：</p>
<p>Local&rarr;Enclosed&rarr;Global&rarr;Built in</p>
<p>Local 指的就是函数或者类的方法内部<br />
Enclosed 指的是嵌套函数（一个函数包裹另一个函数，闭包）<br />
Global 指的是模块中的全局变量<br />
Built in 指的是 Python 为自己保留的特殊名称。  </p>
<p>如果某个 name 映射在局部(local)命名空间中没有找到，接下来就会在闭包作用域(enclosed)进行搜索，如果闭包作用域也没有找到，Python 就会到全局(global)命名空间中进行查找，最后会在内建(built-in)命名空间搜索 （如果一个名称在所有命名空间中都没有找到，就会产生一个 NameError）。
<div class="highlight"><pre><span></span><code>#测试 LEGB
str = &quot;global&quot;
def outer():
    str = &quot;outer&quot;

    def inner():
        str = &quot;inner&quot;
        print(str)
    inner()

outer()
</code></pre></div>
我们依次将几个 str 注释掉，观察控制台打印的内容，体会 LEBG 的搜索顺序。</p>
<h2 id="_129">面向对象编程<a class="headerlink" href="#_129" title="Permanent link">&para;</a></h2>
<p>面向对象（Object oriented Programming，OOP）编程的思想主要是针对大型软件设计而来的。面向对象编程使程序的扩展性更强、可读性更好，使的编程可以像搭积木一样简单。</p>
<p>面向对象编程将数据和操作数据相关的方法封装到对象中，组织代码和数据的方式更加接近人的思维，从而大大提高了编程的效率。</p>
<p>Python 完全采用了面向对象的思想，是真正面向对象的编程语言，完全支持面向对象的基本功能，例如：继承、多态、封装等。</p>
<p>Python 中，一切皆对象。我们在前面学习的数据类型、函数等，都是对象。</p>
<p>注：Python 支持面向过程、面向对象、函数式编程等多种编程范式。</p>
<h3 id="_130">面向对象和面向过程区别<a class="headerlink" href="#_130" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p>面向过程(Procedure Oriented)思维<br />
面向过程编程更加关注的是“程序的逻辑流程”，是一种“执行者”思维，适合编写小规模的程序。<br />
面向过程思想思考问题时，我们首先思考“怎么按步骤实现？”并将步骤对应成方法，一步一步，最终完成。 这个适合简单任务，不需要过多协作的情况下。比如，如何开车？<br />
我们很容易就列出实现步骤：  </p>
<ol>
<li>发动车 </li>
<li>挂挡 </li>
<li>踩油门 </li>
<li>走你<br />
面向过程适合简单、不需要协作的事务。 但是当我们思考比较复杂的问题，比如“如何造车？”，就会发现列出 1234 这样的步骤，是不可能的。那是因为，造车太复杂，需要很多协作才能完成。此时面向对象思想就应运而生了。</li>
</ol>
</li>
<li>
<p>面向对象(Object Oriented)思维
面向对象更加关注的是“软件中对象之间的关系”，是一种“设计者”思维，适合编写大规模的程序。<br />
面向对象(Object)思想更契合人的思维模式。我们首先思考的是“怎么设计这个事物？”<br />
比如思考造车，我们就会先思考“车怎么设计？”，而不是“怎么按步骤造车的问题”。这就是思维方式的转变。<br />
面向对象方式思考造车，发现车由如下对象组成：  </p>
<ol>
<li>轮胎</li>
<li>发动机</li>
<li>车壳</li>
<li>座椅</li>
<li>挡风玻璃<br />
为了便于协作，我们找轮胎厂完成制造轮胎的步骤，发动机厂完成制造发动机的步骤；这样，发现大家可以同时进行车的制造，最终进行组装，大大提高了效率。但是，具体到轮胎厂的一个流水线操作，仍然是有步骤的，还是离不开面向过程思想！ </li>
</ol>
</li>
</ul>
<p>因此，面向对象可以帮助我们从宏观上把握、从整体上分析整个系统。 但是，具体到实现部分的微观操作（就是一个个方法），仍然需要面向过程的思路去处理。</p>
<p>我们千万不要把面向过程和面向对象对立起来。他们是相辅相成的。面向对象离不开面向过程！</p>
<h3 id="_131">对象的进化<a class="headerlink" href="#_131" title="Permanent link">&para;</a></h3>
<p>随着编程面临的问题越来越复杂，编程语言本身也在进化，从主要处理简单数据开始，随着数据变多进化“数组”； 数据类型变复杂，进化出了“结构体”； 处理数据的方式和逻辑变复杂，进化出了“对象”。</p>
<ol>
<li>简单数据<br />
像 30,40，50.4 等这些数字，可以看做是简单数据。最初的计算机编程，都是像这样的数字。</li>
<li>数组<br />
将同类型的数据放到一起。比如：整数数组[20,30,40]，浮点数数组[10.2, 11.3, 12.4]，字符串数组：[“aa”,”bb”,”cc”]</li>
<li>结构体<br />
将不同类型的数据放到一起，是 C 语言中的数据结构。比如：
<div class="highlight"><pre><span></span><code>struct resume{
    int age;
    char name[10];
    double salary;
};
</code></pre></div></li>
<li>对象<br />
将不同类型的数据、方法（即函数）放到一起，就是对象。比如：
<div class="highlight"><pre><span></span><code>class Student:
    company = &quot;SXT&quot; #类属性
    count = 0 #类属性

    def __init__(self,name,score):
        self.name = name #实例属性
        self.score = score
        Student.count = Student.count+1

    def say_score(self): #实例方法
        print(&quot;我的公司是：&quot;,Student.company)
        print(self.name,&#39;的分数是：&#39;,self.score)
</code></pre></div>
我们前面学习的数字也是对象。比如：整数 9，就是一个包含了加法、乘法等方法的对象。</li>
</ol>
<h3 id="_132">类的定义<a class="headerlink" href="#_132" title="Permanent link">&para;</a></h3>
<p>我们把对象比作一个“饼干”，类就是制造这个饼干的“模具”。</p>
<p><img alt="alt text" src="../image-31.png" /></p>
<p>我们通过类定义数据类型的属性（数据）和方法（行为）,也就是说，“类将行为和状态打包在一起”。</p>
<p><img alt="alt text" src="../image-32.png" /></p>
<p>对象是类的具体实体，一般称为“类的实例”。类看做“饼干模具”，对象就是根据这个“模具”制造出的“饼干”。</p>
<p>从一个类创建对象时，每个对象会共享这个类的行为（类中定义的方法），但会有自己的属性值（不共享状态）。更具体一点：“方法代码是共享的，属性数据不共享”。</p>
<p><img alt="alt text" src="../image-33.png" /></p>
<p>Python 中，“一切皆对象”。类也称为“类对象”，类的实例也称为“实例对象”。</p>
<p>定义类的语法格式如下：
<div class="highlight"><pre><span></span><code>class 类名：
    类体
</code></pre></div>
要点如下：</p>
<ol>
<li>类名必须符合“标识符”的规则；一般规定，首字母大写，多个单词使用“驼峰原则”。</li>
<li>类体中我们可以定义属性和方法。</li>
<li>属性用来描述数据，方法(即函数)用来描述这些数据相关的操作。</li>
</ol>
<p>【操作】一个典型的类的定义
<div class="highlight"><pre><span></span><code>class Student:
    def __init__(self,name,score): #构造方法第一个参数必须为 self
        self.name = name #实例属性
        self.score = score

    def say_score(self): #实例方法
        print(self.name,&#39;的分数是：&#39;,self.score)

s1 = Student(&#39;张三&#39;,80) #s1 是实例对象，自动调用__init__()方法
s1.say_score()
</code></pre></div></p>
<h3 id="__init____new__">__init__构造方法和__new__方法<a class="headerlink" href="#__init____new__" title="Permanent link">&para;</a></h3>
<p>类是抽象的，也称之为“对象的模板”。我们需要通过类这个模板，创建类的实例对象，然后才能使用类定义的功能。</p>
<p>我们前面说过一个 Python 对象包含三个部分：id（identity 识别码）、type（对象类型）、value（对象的值）。</p>
<p>现在，我们可以更进一步的说，一个 Python 对象包含如下部分：</p>
<ol>
<li>id（identity 识别码）</li>
<li>type（对象类型）</li>
<li>value（对象的值）<ul>
<li>属性（attribute）</li>
<li>方法（method）</li>
</ul>
</li>
</ol>
<p>创建对象，我们需要定义构造函数__init__()方法。构造方法用于执行“实例对象的初始化工作”，即对象创建后，初始化当前对象的相关属性，无返回值。</p>
<p><strong>init</strong>()的要点如下：</p>
<ol>
<li>名称固定，必须为：<strong>init</strong>()</li>
<li>第一个参数固定，必须为：self。 self 指的就是刚刚创建好的实例对象。</li>
<li>构造函数通常用来初始化实例对象的实例属性，如下代码就是初始化实例属性：name 和 score。<br />
<div class="highlight"><pre><span></span><code>def __init__(self,name,score):
    self.name = name #实例属性
    self.score = score
</code></pre></div></li>
<li>通过“类名(参数列表)”来调用构造函数。调用后，将创建好的对象返回给相应的变量。<br />
比如：s1 = Student('张三', 80)</li>
<li>__init__()方法：初始化创建好的对象，初始化指的是：“给实例属性赋值”。</li>
<li>__new__()方法: 用于创建对象，但我们一般无需重定义该方法。</li>
<li>如果我们不定义__init__方法，系统会提供一个默认的__init__方法。如果我们定义了带参的__init__方法，系统不创建默认的__init__方法。</li>
</ol>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Python 中的 self 相当于 C++ 中的 self 指针，JAVA 和 C# 中的 this 关键字。Python 中，self 必须为构造函数的第一个参数，名字可以任意修改。但一般遵守惯例，都叫做 self。</p>
</div>
<h3 id="_133">实例属性和实例方法<a class="headerlink" href="#_133" title="Permanent link">&para;</a></h3>
<h4 id="_134">实例属性<a class="headerlink" href="#_134" title="Permanent link">&para;</a></h4>
<p>实例属性是从属于实例对象的属性，也称为“实例变量”。他的使用有如下几个要点：</p>
<ol>
<li>实例属性一般在__init__()方法中通过如下代码定义：<br />
self.实例属性名 = 初始值</li>
<li>在本类的其他实例方法中，也是通过 self 进行访问：<br />
self.实例属性名</li>
<li>创建实例对象后，通过实例对象访问：<br />
obj01 = 类名() #创建对象，调用__init__()初始化属性<br />
obj01.实例属性名 = 值 #可以给已有属性赋值，也可以新加属性  </li>
</ol>
<h4 id="_135">实例方法<a class="headerlink" href="#_135" title="Permanent link">&para;</a></h4>
<p>实例方法是从属于实例对象的方法。实例方法的定义格式如下：
<div class="highlight"><pre><span></span><code>def 方法名(self [, 形参列表])：
    函数体

方法的调用格式如下：
对象.方法名([实参列表])
</code></pre></div>
要点：</p>
<ol>
<li>定义实例方法时，第一个参数必须为 self。和前面一样，self 指当前的实例对象。</li>
<li>调用实例方法时，不需要也不能给 self 传参。self 由解释器自动传参。</li>
</ol>
<p>函数和方法的区别</p>
<ol>
<li>都是用来完成一个功能的语句块，本质一样。</li>
<li>方法调用时，通过对象来调用。方法从属于特定实例对象，普通函数没有这个特点。</li>
<li>直观上看，方法定义时需要传递 self，函数不需要。</li>
</ol>
<p>实例对象的方法调用本质：<br />
<img alt="alt text" src="../image-34.png" /></p>
<p>其他操作：</p>
<ol>
<li>dir(obj)可以获得对象的所有属性、方法</li>
<li>obj.__dict__对象的属性字典</li>
<li>pass 空语句</li>
<li>isinstance（对象,类型） 判断“对象”是不是“指定类型”</li>
</ol>
<h3 id="_136">类对象、类属性、类方法、静态方法<a class="headerlink" href="#_136" title="Permanent link">&para;</a></h3>
<h4 id="_137">类对象<a class="headerlink" href="#_137" title="Permanent link">&para;</a></h4>
<p>我们在前面讲的类定义格式中，“class 类名：”。实际上，当解释器执行 class 语句时，就会创建一个类对象。</p>
<p>【操作】测试类对象的生成
<div class="highlight"><pre><span></span><code>class Student:
    pass #空语句

print(type(Student))
print(id(Student))

Stu2 = Student
s1 = Stu2()
print(s1)
</code></pre></div>
执行结果如下：
<div class="highlight"><pre><span></span><code>&lt;class &#39;type&#39;&gt;
51686328
&lt;__main__.Student object at 0x0000000002B5FDD8&gt;
</code></pre></div></p>
<p>我们可以看到实际上生成了一个变量名就是类名“Student”的对象。我们通过赋值给新变量 Stu2，也能实现相关的调用。说明，确实创建了“类对象”。</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>pass 为空语句。就是表示什么都不做，只是作为一个占位符存在。当你写代码时，遇到暂时不知道往方法或者类中加入什么时，可以先用 pass 占位，后期再补上。</p>
</div>
<h4 id="_138">类属性<a class="headerlink" href="#_138" title="Permanent link">&para;</a></h4>
<p>类属性是从属于“类对象”的属性，也称为“类变量”。由于，类属性从属于类对象，可以被所有实例对象共享。</p>
<p>类属性的定义方式：
<div class="highlight"><pre><span></span><code>class 类名：
    类变量名= 初始值
</code></pre></div>
在类中或者类的外面，我们可以通过：“类名.类变量名”来读写。</p>
<p>【操作】 类属性的使用测试
<div class="highlight"><pre><span></span><code>class Student:
    company = &quot;SXT&quot; #类属性
    count = 0 #类属性

    def __init__(self,name,score):
        self.name = name #实例属性
        self.score = score
        Student.count = Student.count+1

    def say_score(self): #实例方法
        print(&quot;我的公司是：&quot;,Student.company)
        print(self.name,&#39;的分数是：&#39;,self.score)

s1 = Student(&#39;张三&#39;,80) #s1 是实例对象，自动调用__init__()方法
s1.say_score()
print(&#39;一共创建{0}个 Student 对象&#39;.format(Student.count))
</code></pre></div>
执行结果：
<div class="highlight"><pre><span></span><code>我的公司是： SXT
张三 的分数是： 80
一共创建 1 个 Student 对象
</code></pre></div></p>
<h4 id="_139">类方法<a class="headerlink" href="#_139" title="Permanent link">&para;</a></h4>
<p>类方法是从属于“类对象”的方法。类方法通过装饰器 @classmethod 来定义，格式如下：
<div class="highlight"><pre><span></span><code>@classmethod
def 类方法名(cls [，形参列表]) ：
    函数体
</code></pre></div>
要点如下：</p>
<ol>
<li>@classmethod 必须位于方法上面一行</li>
<li>第一个 cls 必须有；cls 指的就是“类对象”本身；</li>
<li>调用类方法格式：“类名.类方法名(参数列表)”。 参数列表中，不需要也不能给 cls 传值。</li>
<li>类方法中访问实例属性和实例方法会导致错误。</li>
<li>子类继承父类方法时，传入 cls 是子类对象，而非父类对象</li>
</ol>
<p>【操作】类方法使用测试
<div class="highlight"><pre><span></span><code>class Student:
    company = &quot;SXT&quot; #类属性

    @classmethod
    def printCompany(cls):
        print(cls.company)

Student.printCompany()
</code></pre></div></p>
<h4 id="_140">静态方法<a class="headerlink" href="#_140" title="Permanent link">&para;</a></h4>
<p>Python 中允许定义与“类对象”无关的方法，称为“静态方法”。</p>
<p>“静态方法”和在模块中定义普通函数没有区别，只不过“静态方法”放到了“类的名字空间里面”，需要通过“类调用”。</p>
<p>静态方法通过装饰器@staticmethod 来定义，格式如下：
<div class="highlight"><pre><span></span><code>@staticmethod
def 静态方法名([形参列表]) ：
    函数体
</code></pre></div>
要点如下：</p>
<ol>
<li>@staticmethod 必须位于方法上面一行。</li>
<li>调用静态方法格式：“类名.静态方法名(参数列表)”。</li>
<li>静态方法中访问实例属性和实例方法会导致错误。</li>
</ol>
<p>【操作】静态方法使用测试
<div class="highlight"><pre><span></span><code>class Student:
    company = &quot;SXT&quot; # 类属性

    @staticmethod
    def add(a, b): # 静态方法
        print(&quot;{0}+{1}={2}&quot;.format(a,b,(a+b)))
        return a+b

Student.add(20,30)
</code></pre></div></p>
<h3 id="_141">内存分析实例对象和类对象创建过程<a class="headerlink" href="#_141" title="Permanent link">&para;</a></h3>
<p>我们以下面代码为例，分析整个创建过程，让大家对面向对象概念掌握更加深刻：
<div class="highlight"><pre><span></span><code>class Student:
    company = &quot;尚学堂&quot; #类属性
    count = 0 #类属性

    def __init__(self,name,score):
        self.name = name #实例属性
        self.score = score
        Student.count = Student.count+1

    def say_score(self): #实例方法
        print(&quot;我的公司是：&quot;,Student.company)
        print(self.name,&#39;的分数是：&#39;,self.score)

s1 = Student(&#39;高淇&#39;,80) #s1 是实例对象，自动调用__init__()方法
s1.say_score()
print(&#39;一共创建{0}个 Student 对象&#39;.format(Student.count))
</code></pre></div></p>
<p><img alt="alt text" src="../image-35.png" /></p>
<h3 id="__del__">__del__方法(析构函数)和垃圾回收机制<a class="headerlink" href="#__del__" title="Permanent link">&para;</a></h3>
<p>__del__方法称为“析构方法”，用于实现对象被销毁时所需的操作。比如：释放对象占用的资源，例如：打开的文件资源、网络连接等。</p>
<p>Python 实现自动的垃圾回收，当对象没有被引用时（引用计数为 0），由垃圾回收器调用__del__方法。</p>
<p>我们也可以通过 del 语句删除对象，从而保证调用__del__方法。</p>
<p>系统会自动提供__del__方法，一般不需要自定义析构方法。
<div class="highlight"><pre><span></span><code>#析构函数
class Person:
    def __del__(self):
        print(&quot;销毁对象：{0}&quot;.format(self))

p1 = Person()
p2 = Person()
del p2
print(&quot;程序结束&quot;)
</code></pre></div>
运算结果：
<div class="highlight"><pre><span></span><code>销毁对象：&lt;__main__.Person object at 0x02175610&gt;
程序结束
销毁对象：&lt;__main__.Person object at 0x021755D0&gt;
</code></pre></div></p>
<h3 id="__call__">__call__方法和可调用对象<a class="headerlink" href="#__call__" title="Permanent link">&para;</a></h3>
<p>定义了__call__方法的对象，称为“可调用对象”，即该对象可以像函数一样被调用。
<div class="highlight"><pre><span></span><code>#测试__call__，可调用对象
class SalaryAccount:
    &#39;&#39;&#39;工资计算类&#39;&#39;&#39;

    def __call__(self, salary):
        yearSalary = salary*12
        daySalary = salary//30
        hourSalary = daySalary//8

        return dict(monthSalary=salary,yearSalary=yearSalary,daySalary=daySalary,hourSalary=hourSalary)

s = SalaryAccount()

print(s(5000)) #可以像调用函数一样调用对象的__call__方法
</code></pre></div>
运行结果：
<div class="highlight"><pre><span></span><code>{&#39;monthSalary&#39;: 5000, &#39;yearSalary&#39;: 60000, &#39;daySalary&#39;: 166, &#39;hourSalary&#39;: 20}
</code></pre></div></p>
<h3 id="_142">方法没有重载<a class="headerlink" href="#_142" title="Permanent link">&para;</a></h3>
<p>在其他语言中，可以定义多个重名的方法，只要保证方法签名唯一即可。方法签名包含 3个部分：方法名、参数数量、参数类型。</p>
<p>Python 中，方法的的参数没有声明类型（调用时确定参数的类型），参数的数量也可以由可变参数控制。因此，Python 中是没有方法的重载的。定义一个方法即可有多种调用方式，相当于实现了其他语言中的方法的重载。</p>
<p>如果我们在类体中定义了多个重名的方法，只有最后一个方法有效。</p>
<p>建议：不要使用重名的方法！Python 中方法没有重载。
<div class="highlight"><pre><span></span><code>#Python 中没有方法的重载。定义多个同名方法，只有最后一个有效

class Person:
    def say_hi(self):
        print(&quot;hello&quot;)

    def say_hi(self,name):
        print(&quot;{0},hello&quot;.format(name))

p1 = Person()

#p1.say_hi() #不带参，报错：TypeError: say_hi() missing 1 required positional argument: &#39;name&#39;

p1.say_hi(&quot;高淇&quot;)
</code></pre></div></p>
<h3 id="_143">方法的动态性<a class="headerlink" href="#_143" title="Permanent link">&para;</a></h3>
<p>Python 是动态语言，我们可以动态的为类添加新的方法，或者动态的修改类的已有的方法。
<div class="highlight"><pre><span></span><code>#测试方法的动态性

class Person:
    def work(self):
        print(&quot;努力上班！&quot;)

def play_game(self):
    print(&quot;{0}玩游戏&quot;.format(self))

def work2(s):
    print(&quot;好好工作，努力上班！&quot;)

Person.play = play_game
Person.work = work2

p = Person()
p.play()
p.work()
</code></pre></div>
我们可以看到，Person 动态的新增了 play_game 方法，以及用 work2 替换了 work 方法。</p>
<h3 id="_144">私有属性和私有方法(实现封装)<a class="headerlink" href="#_144" title="Permanent link">&para;</a></h3>
<p>Python 对于类的成员没有严格的访问控制限制，这与其他面向对象语言有区别。关于私有属性和私有方法，有如下要点：</p>
<ol>
<li>通常我们约定，两个下划线开头的属性是私有的(private)。其他为公共的(public)。</li>
<li>类内部可以访问私有属性(方法)</li>
<li>类外部不能直接访问私有属性(方法)</li>
<li>类外部可以通过“_类名__私有属性(方法)名”访问私有属性(方法)</li>
</ol>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>方法本质上也是属性！只不过是可以通过()执行而已。所以，此处讲的私有属性和公有属性，也同时讲解了私有方法和公有方法的用法。如下测试中，同时也包含了私有方法和公有方法的例子。</p>
</div>
<p>【测试】私有属性和公有属性使用测试
<div class="highlight"><pre><span></span><code>#测试私有属性、私有方法

class Employee:
    __company = &quot;百战程序员&quot; #私有类属性. 通过 dir 可以查到_Employee__company

    def __init__(self,name,age):
        self.name = name
        self.__age = age #私有实例属性

    def say_company(self):
        print(&quot;我的公司是：&quot;,Employee.__company) #类内部可以直接访问私有属性
        print(self.name,&quot;的年龄是：&quot;,self.__age)
        self.__work()

    def __work(self): #私有实例方法 通过 dir 可以查到_Employee__work
        print(&quot;工作！好好工作，好好赚钱，娶个媳妇！&quot;)

p1 = Employee(&quot;高淇&quot;,32)
print(p1.name)
print(dir(p1)) #
p1.say_company()
print(p1._Employee__age) #通过这种方式可以直接访问到私有属性 。通过 dir 可以查到属性：_Employee__age
#print(p1.__age) #直接访问私有属性，报错
#p1.__sleep() #直接访问私有方法，报错
</code></pre></div>
执行结果：
<div class="highlight"><pre><span></span><code>高淇
[&#39;_Person__age&#39;, &#39;_Person__leg_num&#39;, &#39;_Person__sleep&#39;, &#39;__class__&#39;, &#39;__delattr__&#39;,
&#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;,
&#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;,
&#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;,
&#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;name&#39;, &#39;say_age&#39;]
我的公司是： 百战程序员
高淇 的年龄是： 18
睡觉
18
</code></pre></div>
从打印的 Person 对象所有属性我们可以看出。私有属性“__age”在实际存储时是按照“_Person__age”这个属性来存储的。这也就是为什么我们不能直接使用“__age”而可以使用“_Person__age”的根本原因。</p>
<h3 id="property">@property 装饰器<a class="headerlink" href="#property" title="Permanent link">&para;</a></h3>
<p>@property 可以将一个方法的调用方式变成“属性调用”。下面是一个简单的示例，让大家体会一下这种转变：
<div class="highlight"><pre><span></span><code>#简单测试@property

class Employee:
    @property
    def salary(self):
        return 30000;

emp1 = Employee()
print(emp1.salary) #打印 30000
print(type(emp1.salary)) #打印&lt;class &#39;int&#39;&gt;
#emp1.salary() #报错：TypeError: &#39;int&#39; object is not callable
#emp1.salary =1000 #@property 修饰的属性，如果没有加 setter 方法，则为只读属性。此处修改报错：AttributeError: can&#39;t set attribute
</code></pre></div>
@property 主要用于帮助我们处理属性的读操作、写操作。对于某一个属性，我们可以直接通过：<br />
emp1.salary = 30000<br />
如上的操作读操作、写操作。但是，这种做法不安全。比如，我需要限制薪水必须为 1-10000 的数字。这时候，我们就需要通过 getter、setter 方法来处理。
<div class="highlight"><pre><span></span><code>#测试@property

class Employee:
    def __init__(self,name,salary):
        self.name = name
        self.__salary = salary

    @property #相当于 salary 属性的 getter 方法
    def salary(self):
        print(&quot;月薪为{0},年薪为{1}&quot;.format(self.__salary,(12*self.__salary)))
        return self.__salary;

    @salary.setter
    def salary(self,salary): #相当于 salary 属性的 setter 方法
        if(0&lt;salary&lt;1000000):
            self.__salary = salary
        else:
            print(&quot;薪水录入错误！只能在 0-1000000 之间&quot;)

emp1 = Employee(&quot;高淇&quot;,100)
print(emp1.salary)

emp1.salary = -200
</code></pre></div>
运行结果：
<div class="highlight"><pre><span></span><code>月薪为 100,年薪为 1200
100
月薪为 100,年薪为 1200
100
薪水录入错误！只能在 0-1000000 之间
</code></pre></div></p>
<h3 id="_145">属性和方法命名总结<a class="headerlink" href="#_145" title="Permanent link">&para;</a></h3>
<ul>
<li>_xxx：保护成员，不能用“from module import * ”导入，只有类对象和子类对象能访问这些成员。</li>
<li>__xxx__：系统定义的特殊成员</li>
<li>__xxx： 类中的私有成员，只有类对象自己能访问，子类对象也不能访问。（但，在类外部可以通过“对象名. _类名__xxx”这种特殊方式访问。Python 不存在严格意义的私有成员）</li>
</ul>
<p>注：再次强调，方法和属性都遵循上面的规则。</p>
<h3 id="_146">类编码风格<a class="headerlink" href="#_146" title="Permanent link">&para;</a></h3>
<ol>
<li>类名首字母大写，多个单词之间采用驼峰原则。</li>
<li>实例名、模块名采用小写，多个单词之间采用下划线隔开。</li>
<li>每个类，应紧跟“文档字符串”，说明这个类的作用。</li>
<li>可以用空行组织代码，但不能滥用。在类中，使用一个空行隔开方法；模块中，使用两个空行隔开多个类。</li>
</ol>
<h3 id="_147">面向对象三大特征介绍<a class="headerlink" href="#_147" title="Permanent link">&para;</a></h3>
<p>Python 是面向对象的语言，也支持面向对象编程的三大特性：继承、封装（隐藏）、多态。</p>
<ul>
<li>封装（隐藏）
隐藏对象的属性和实现细节，只对外提供必要的方法。相当于将“细节封装起来”，只对外暴露“相关调用方法”。<br />
通过前面学习的“私有属性、私有方法”的方式，实现“封装”。Python 追求简洁的语法，没有严格的语法级别的“访问控制符”，更多的是依靠程序员自觉实现。</li>
<li>继承
继承可以让子类具有父类的特性，提高了代码的重用性。<br />
从设计上是一种增量进化，原有父类设计不变的情况下，可以增加新的功能，或者改进已有的算法。</li>
<li>多态
多态是指同一个方法调用由于对象不同会产生不同的行为。生活中这样的例子比比皆是：同样是休息方法，人不同休息方法不同。张三休息是睡觉，李四休息是玩游戏，程序员休息是“敲几行代码”。</li>
</ul>
<h3 id="_148">继承<a class="headerlink" href="#_148" title="Permanent link">&para;</a></h3>
<p>继承是面向对象程序设计的重要特征，也是实现“代码复用”的重要手段。</p>
<p>如果一个新类继承自一个设计好的类，就直接具备了已有类的特征，就大大降低了工作难度。已有的类，我们称为“父类或者基类”，新的类，我们称为“子类或者派生类”。</p>
<h4 id="_149">语法格式<a class="headerlink" href="#_149" title="Permanent link">&para;</a></h4>
<p><div class="highlight"><pre><span></span><code>Python 支持多重继承，一个子类可以继承多个父类。继承的语法格式如下：
class 子类类名(父类 1[，父类 2，...])：
    类体
</code></pre></div>
如果在类定义中没有指定父类，则默认父类是 object 类。也就是说，object 是所有类的父类，里面定义了一些所有类共有的默认实现，比如：__new__()。</p>
<p>定义子类时，必须在其构造函数中调用父类的构造函数。调用格式如下：</p>
<p>父类名.__init__(self, 参数列表)
<div class="highlight"><pre><span></span><code>class Person:
    def __init__(self,name,age):
        self.name = name
        self.__age = age

    def say_age(self):
        print(self.name,&quot;的年龄是：&quot;,self.__age)

class Student(Person):
    def __init__(self,name,age,score):
        self.score = score
        Person.__init__(self,name,age) #构造函数中包含调用父类构造函数。根据需要，不是必须。 子类并不会自动调用父类的__init__()，我们必须显式的调用它。

s1 = Student(&quot;张三&quot;,15,85)
s1.say_age()
print(dir(s1))
</code></pre></div>
运行结果：
<div class="highlight"><pre><span></span><code>张三 的年龄是： 15
[&#39;_Person__age&#39;, &#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;,
&#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;,
&#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;,
&#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;,
&#39;__weakref__&#39;, &#39;name&#39;, &#39;say_age&#39;, &#39;score&#39;]
</code></pre></div></p>
<h4 id="_150">类成员的继承和重写<a class="headerlink" href="#_150" title="Permanent link">&para;</a></h4>
<ol>
<li>成员继承：子类继承了父类除构造方法之外的所有成员。</li>
<li>方法重写：子类可以重新定义父类中的方法，这样就会覆盖父类的方法，也称为“重写”</li>
</ol>
<p>【操作】继承和重写的案例
<div class="highlight"><pre><span></span><code>class Person:
    def __init__(self,name,age):
        self.name = name
        self.age = age

    def say_age(self):
        print(self.name,&quot;的年龄是：&quot;,self.age)

    def say_name(self):
        print(&quot;我是&quot;,self.name)

class Student(Person):
    def __init__(self,name,age,score):
        self.score = score
        Person.__init__(self,name,age) #构造函数中包含调用父类构造函数

    def say_score(self):
        print(self.name,&quot;的分数是：&quot;,self.score)

    def say_name(self): #重写父类的方法
        print(&quot;报告老师，我是&quot;,self.name)

s1 = Student(&quot;张三&quot;,15,85)
s1.say_score()
s1.say_name()
s1.say_age()
</code></pre></div>
执行结果：
<div class="highlight"><pre><span></span><code>张三 的分数是： 85
报告老师，我是 张三
张三 的年龄是： 15
</code></pre></div></p>
<h4 id="_151">查看类的继承层次结构<a class="headerlink" href="#_151" title="Permanent link">&para;</a></h4>
<p>通过类的方法 mro()或者类的属性__mro__可以输出这个类的继承层次结构。  <br />
【操作】 查看类的继承层次结构
<div class="highlight"><pre><span></span><code>class A:pass
class B(A):pass
class C(B):pass

print(C.mro())
</code></pre></div>
执行结果：
<div class="highlight"><pre><span></span><code>[&lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;object&#39;&gt;]
</code></pre></div></p>
<h3 id="object">object 根类<a class="headerlink" href="#object" title="Permanent link">&para;</a></h3>
<p>object 类是所有类的父类，因此所有的类都有 object 类的属性和方法。</p>
<h4 id="dir">dir()查看对象属性<a class="headerlink" href="#dir" title="Permanent link">&para;</a></h4>
<p>为了深入学习对象，我们先学习内置函数 dir()，他可以让我们方便的看到指定对象所有的属性。</p>
<p>【测试】查看对象所有属性以及和 object 进行比对
<div class="highlight"><pre><span></span><code>class Person:
    def __init__(self,name,age):
        self.name = name
        self.age = age

    def say_age(self):
        print(self.name,&quot;的年龄是：&quot;,self.age)

obj = object()
print(dir(obj))

s2 = Person(&quot;高淇&quot;,18)
print(dir(s2))
</code></pre></div>
执行结果：
<div class="highlight"><pre><span></span><code>[&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;,
&#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;,
&#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;,
&#39;__str__&#39;, &#39;__subclasshook__&#39;]
[&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;,
&#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;,
&#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;,
&#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;age&#39;, &#39;name&#39;, &#39;say_age&#39;]
</code></pre></div>
从上面我们可以发现这样几个要点：</p>
<ol>
<li>Person 对象增加了六个属性：
<div class="highlight"><pre><span></span><code>__dict__ __module__ __weakref__ age name say_age
</code></pre></div></li>
<li>object 的所有属性，Person 类作为 object 的子类，显然包含了所有的属性。</li>
<li>我们打印 age、name、say_age，发现 say_age 虽然是方法，实际上也是属性。只不过，这个属性的类型是“method”而已。
<div class="highlight"><pre><span></span><code>age &lt;class &#39;int&#39;&gt;
name &lt;class &#39;str&#39;&gt;
say_age &lt;class &#39;method&#39;&gt;
</code></pre></div></li>
</ol>
<h4 id="__str__">重写__str__()方法<a class="headerlink" href="#__str__" title="Permanent link">&para;</a></h4>
<p>object 有一个__str__()方法，用于返回一个对于“对象的描述”，对应于内置函数 str() 经常用于 print()方法，帮助我们查看对象的信息。__str__()可以重写。
<div class="highlight"><pre><span></span><code>class Person:
    def __init__(self,name,age):
        self.name = name
        self.__age = age

    def __str__(self):
        &#39;&#39;&#39;将对象转化成一个字符串，一般用于 print 方法&#39;&#39;&#39;
        return &quot;名字是：{0},年龄是{1}&quot;.format(self.name,self.__age)

p = Person(&quot;高淇&quot;,18)
print(p)
</code></pre></div>
运行结果：
<div class="highlight"><pre><span></span><code>名字是：高淇,年龄是 18
</code></pre></div></p>
<h3 id="_152">多重继承<a class="headerlink" href="#_152" title="Permanent link">&para;</a></h3>
<p>Python 支持多重继承，一个子类可以有多个“直接父类”。这样，就具备了“多个父类”的特点。但是由于，这样会被“类的整体层次”搞的异常复杂，尽量避免使用。
<div class="highlight"><pre><span></span><code>#多重继承
class A:
    def aa(self):
        print(&quot;aa&quot;)

class B:
    def bb(self):
        print(&quot;bb&quot;)

class C(B,A):
    def cc(self):
        print(&quot;cc&quot;)

c = C()
c.cc()
c.bb()
c.aa()
</code></pre></div>
运算结果：
<div class="highlight"><pre><span></span><code>cc
bb
aa
</code></pre></div></p>
<h3 id="mro">MRO()<a class="headerlink" href="#mro" title="Permanent link">&para;</a></h3>
<p>Python 支持多继承，如果父类中有相同名字的方法，在子类没有指定父类名时，解释器将“从左向右”按顺序搜索。</p>
<p>MRO（Method Resolution Order）：方法解析顺序。 我们可以通过 mro()方法获得“类的层次结构”，方法解析顺序也是按照这个“类的层次结构”寻找的。
<div class="highlight"><pre><span></span><code>#多重继承
class A:
    def aa(self):
        print(&quot;aa&quot;)

    def say(self):
        print(&quot;say AAA!&quot;)

class B:
    def bb(self):
        print(&quot;bb&quot;)

    def say(self):
        print(&quot;say BBB!&quot;)

class C(B,A):
    def cc(self):
        print(&quot;cc&quot;)

c = C()
print(C.mro()) #打印类的层次结构
c.say() #解释器寻找方法是“从左到右”的方式寻找，此时会执行 B 类中的 say()
</code></pre></div></p>
<h3 id="super">super()获得父类定义<a class="headerlink" href="#super" title="Permanent link">&para;</a></h3>
<p>在子类中，如果想要获得父类的方法时，我们可以通过 super()来做。 </p>
<p>super()代表父类的定义，不是父类对象。
<div class="highlight"><pre><span></span><code>#super()

class A:
    def say(self):
        print(&quot;A: &quot;,self)
        print(&quot;say AAA&quot;)

class B(A):
    def say(self):
        #A.say(self) 调用父类的 say 方法
        super().say() #通过 super()调用父类的方法
        print(&quot;say BBB&quot;)

b = B()
b.say()
</code></pre></div>
运行结果：
<div class="highlight"><pre><span></span><code>A: &lt;__main__.B object at 0x007A5690&gt;
say AAA
say BBB
</code></pre></div></p>
<h3 id="_153">多态<a class="headerlink" href="#_153" title="Permanent link">&para;</a></h3>
<p>多态（polymorphism）是指同一个方法调用由于对象不同可能会产生不同的行为。在现实生活中，我们有很多例子。比如：同样是调用人的休息方法，张三的休息是睡觉，李四的休息是玩游戏，高淇老师是敲代码。同样是吃饭的方法，中国人用筷子吃饭，英国人用刀叉吃饭，印度人用手吃饭。</p>
<p>关于多态要注意以下 2 点：</p>
<ol>
<li>多态是方法的多态，属性没有多态。</li>
<li>多态的存在有 2 个必要条件：继承、方法重写。
<div class="highlight"><pre><span></span><code>#多态
class Animal:
    def shout(self):
        print(&quot;动物叫了一声&quot;)

class Dog(Animal):
    def shout(self):
        print(&quot;小狗，汪汪汪&quot;)

class Cat(Animal):
    def shout(self):
        print(&quot;小猫，喵喵喵&quot;)

def animalShout(a):
    if isinstance(a,Animal):
        a.shout() #传入的对象不同，shout 方法对应的实际行为也不同。

animalShout(Dog())
animalShout(Cat())
</code></pre></div>
运行结果：
<div class="highlight"><pre><span></span><code>小狗，汪汪汪
小猫，喵喵喵
</code></pre></div></li>
</ol>
<h3 id="_154">特殊方法和运算符重载<a class="headerlink" href="#_154" title="Permanent link">&para;</a></h3>
<p>Python 的运算符实际上是通过调用对象的特殊方法实现的。比如：
<div class="highlight"><pre><span></span><code>a = 20
b = 30
c = a+b
d = a.__add__(b)
print(&quot;c=&quot;,c)
print(&quot;d=&quot;,d)
</code></pre></div>
运算结果：
<div class="highlight"><pre><span></span><code>c= 50
d= 50
</code></pre></div>
常见的特殊方法统计如下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>__init__</td>
<td>构造方法</td>
<td>对象创建：p = Person()</td>
</tr>
<tr>
<td>__del__</td>
<td>析构方法</td>
<td>对象回收</td>
</tr>
<tr>
<td>__repr__,__str__</td>
<td>打印，转换 print(a)</td>
<td></td>
</tr>
<tr>
<td>__call__</td>
<td>函数调用</td>
<td>a()</td>
</tr>
<tr>
<td>__getattr__</td>
<td>点号运算</td>
<td>a.xxx</td>
</tr>
<tr>
<td>__setattr__</td>
<td>属性赋值</td>
<td>a.xxx = value</td>
</tr>
<tr>
<td>__getitem__</td>
<td>索引运算</td>
<td>a[key]</td>
</tr>
<tr>
<td>__setitem__</td>
<td>索引赋值</td>
<td>a[key]=value</td>
</tr>
<tr>
<td>__len__</td>
<td>长度</td>
<td>len(a)</td>
</tr>
</tbody>
</table>
<p>每个运算符实际上都对应了相应的方法，统计如下：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>特殊方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>运算符+</td>
<td>__add__</td>
<td>加法</td>
</tr>
<tr>
<td>运算符-</td>
<td>__sub__</td>
<td>减法</td>
</tr>
<tr>
<td>&lt;,&lt;=,==</td>
<td>__lt__,__le__，__eq__</td>
<td>比较运算符</td>
</tr>
<tr>
<td>&gt;,&gt;=,!=</td>
<td>__gt__,__ge__,__ne__</td>
<td></td>
</tr>
<tr>
<td>&lt;&lt;,&gt;&gt;</td>
<td>__lshift__,__rshift__</td>
<td>左移、右移</td>
</tr>
<tr>
<td>*,/,%,//</td>
<td>__mul__,__truediv__,__mod__,__floordiv__</td>
<td>乘、浮点除、模运算（取余）、整数除</td>
</tr>
<tr>
<td>**</td>
<td>__pow__</td>
<td>指数运算</td>
</tr>
</tbody>
</table>
<p>我们可以重写上面的特殊方法，即实现了“运算符的重载”。
<div class="highlight"><pre><span></span><code>#测试运算符的重载
class Person:
    def __init__(self,name):
        self.name = name

    def __add__(self, other):
        if isinstance(other,Person):
            return &quot;{0}--{1}&quot;.format(self.name,other.name)
        else:
            return &quot;不是同类对象， 不能相加&quot;

    def __mul__(self, other):
        if isinstance(other,int):
            return self.name*other
        else:
            return &quot;不是同类对象， 不能相乘&quot;

p1 = Person(&quot;高淇&quot;)
p2 = Person(&quot;高希希&quot;)

x = p1 + p2
print(x)

print(p1*3)
</code></pre></div>
运算结果：
<div class="highlight"><pre><span></span><code>高淇--高希希
高淇高淇高淇
</code></pre></div></p>
<h3 id="_155">特殊属性<a class="headerlink" href="#_155" title="Permanent link">&para;</a></h3>
<p>Python 对象中包含了很多双下划线开始和结束的属性，这些是特殊属性，有特殊用法。这里我们列出常见的特殊属性：</p>
<p><img alt="alt text" src="../image-36.png" /></p>
<p><div class="highlight"><pre><span></span><code>#测试特殊属性
class A:
    pass

class B:
    pass

class C(B,A):
    def __init__(self,nn):
        self.nn = nn

    def cc(self):
        print(&quot;cc&quot;)

c = C(3)

print(dir(c))
print(c.__dict__)
print(c.__class__)
print(C.__bases__)
print(C.mro())
print(A.__subclasses__())
</code></pre></div>
运行结果：
<div class="highlight"><pre><span></span><code>[&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;,
&#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;,
&#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;,
&#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;cc&#39;, &#39;nn&#39;]
{&#39;nn&#39;: 3}
&lt;class &#39;__main__.C&#39;&gt;
(&lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;)
[&lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;object&#39;&gt;]
[&lt;class &#39;__main__.C&#39;&gt;]
</code></pre></div></p>
<h3 id="_156">对象的浅拷贝和深拷贝<a class="headerlink" href="#_156" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p>变量的赋值操作<br />
只是形成两个变量，实际还是指向同一个对象。</p>
</li>
<li>
<p>浅拷贝<br />
Python 拷贝一般都是浅拷贝。拷贝时，对象包含的子对象内容不拷贝。因此，源对象和拷贝对象会引用同一个子对象。</p>
</li>
<li>
<p>深拷贝<br />
使用 copy 模块的 deepcopy 函数，递归拷贝对象中包含的子对象。源对象和拷贝对象所有的子对象也不同。</p>
</li>
</ul>
<p><div class="highlight"><pre><span></span><code>#测试对象的引用赋值、浅拷贝、深拷贝
import copy

class MobilePhone:
    def __init__(self,cpu,screen):
        self.cpu = cpu
        self.screen = screen

class CPU:
    def calculate(self):
        print(&quot;计算，算个 12345&quot;)
        print(&quot;CPU 对象:&quot;,self)

class Screen:
    def show(self):
        print(&quot;显示一个好看的画面，亮瞎你的钛合金大眼&quot;)
        print(&quot;屏幕对象：&quot;,self)

c = CPU()
s = Screen()
m = MobilePhone(c,s)

m.cpu.calculate()

n = m #两个变量，但是指向了同一个对象
print(m,n)

m2 = copy.copy(m) #m2 是新拷贝的另一个手机对象
print(m,m2)

m.cpu.calculate()
m2.cpu.calculate() #m2 和 m 拥有了一样的 cpu 对象和 screen 对象

m3 = copy.deepcopy(m)
m3.cpu.calculate() #m3 和 m 拥有不一样的 cpu 对象和 screen 对象
</code></pre></div>
运算结果：
<div class="highlight"><pre><span></span><code>计算，算个 12345
CPU 对象: &lt;__main__.CPU object at 0x00685690&gt;
&lt;__main__.MobilePhone object at 0x00685B50&gt; &lt;__main__.MobilePhone object at 0x00685B50&gt;
&lt;__main__.MobilePhone object at 0x00685B50&gt; &lt;__main__.MobilePhone object at 0x0069B490&gt;
计算，算个 12345
CPU 对象: &lt;__main__.CPU object at 0x00685690&gt;
计算，算个 12345
CPU 对象: &lt;__main__.CPU object at 0x00685690&gt;
计算，算个 12345
CPU 对象: &lt;__main__.CPU object at 0x006A5DB0&gt;
</code></pre></div></p>
<h3 id="_157">组合<a class="headerlink" href="#_157" title="Permanent link">&para;</a></h3>
<p>“is-a”关系，我们可以使用“继承”。从而实现子类拥有的父类的方法和属性。“is-a”关系指的是类似这样的关系：狗是动物，dog is animal。狗类就应该继承动物类。</p>
<p>“has-a”关系，我们可以使用“组合”，也能实现一个类拥有另一个类的方法和属性。”has-a”关系指的是这样的关系：手机拥有 CPU。 MobilePhone has a CPU。
<div class="highlight"><pre><span></span><code>#组合测试
class MobilePhone:
    def __init__(self,cpu,screen):
        self.cpu = cpu
        self.screen = screen

class CPU:
    def calculate(self):
        print(&quot;计算，算个 12345&quot;)

class Screen:
    def show(self):
        print(&quot;显示一个好看的画面，亮瞎你的钛合金大眼&quot;)

c = CPU()
s = Screen()
m = MobilePhone(c,s)
m.cpu.calculate() #通过组合，我们也能调用 cpu 对象的方法。相当于手机对象间接拥有了“cpu 的方法”
m.screen.show()
</code></pre></div>
运算结果：
<div class="highlight"><pre><span></span><code>计算，算个 12345
显示一个好看的画面，亮瞎你的钛合金大眼
</code></pre></div></p>
<h3 id="_">设计模式_工厂模式<a class="headerlink" href="#_" title="Permanent link">&para;</a></h3>
<p>设计模式是面向对象语言特有的内容，是我们在面临某一类问题时候固定的做法，设计模式有很多种，比较流行的是：GOF（Goup Of Four）23 种设计模式。当然，我们没有必要全部学习，学习几个常用的即可。</p>
<p>对于初学者，我们学习两个最常用的模式：工厂模式和单例模式。</p>
<p>工厂模式实现了创建者和调用者的分离，使用专门的工厂类将选择实现类、创建对象进行统一的管理和控制。
<div class="highlight"><pre><span></span><code>#工厂模式
class CarFactory:
    def createCar(self,brand):
        if brand == &quot;奔驰&quot;:
            return Benz()
        elif brand == &quot;宝马&quot;:
            return BMW()
        elif brand == &#39;比亚迪&#39;:
            return BYD()
        else:
            return &quot;未知品牌，无法创建&quot;

class Benz:
    pass

class BMW:
    pass

class BYD:
    pass

factory = CarFactory()
c1 = factory.createCar(&quot;奔驰&quot;)
c2 = factory.createCar(&quot;宝马&quot;)
print(c1)
print(c2)
</code></pre></div>
运行结果：
<div class="highlight"><pre><span></span><code>&lt;__main__.Benz object at 0x021C5770&gt;
&lt;__main__.BMW object at 0x021C5790&gt;
</code></pre></div></p>
<h3 id="__1">设计模式_单例模式<a class="headerlink" href="#__1" title="Permanent link">&para;</a></h3>
<p>单例模式（Singleton Pattern）的核心作用是确保一个类只有一个实例，并且提供一个访问该实例的全局访问点。</p>
<p>单例模式只生成一个实例对象，减少了对系统资源的开销。当一个对象的产生需要比较多的资源，如读取配置文件、产生其他依赖对象时，可以产生一个“单例对象”，然后永久驻留内存中，从而极大的降低开销。</p>
<p>单例模式有多种实现的方式，我们这里推荐重写__new__()的方法。
<div class="highlight"><pre><span></span><code>#单例模式
class MySingleton:
    __obj = None
    __init_flag = True

    def __new__(cls, *args, **kwargs):
        if cls.__obj == None:
            cls.__obj = object.__new__(cls)
            return cls.__obj

    def __init__(self,name):
        if MySingleton.__init_flag:
            print(&quot;init....&quot;)
            self.name = name
            MySingleton.__init_flag = False

a = MySingleton(&quot;aa&quot;)
print(a)
b = MySingleton(&quot;bb&quot;)
print(b)
</code></pre></div>
运算结果：
<div class="highlight"><pre><span></span><code>init....
&lt;__main__.MySingleton object at 0x01E15610&gt;
&lt;__main__.MySingleton object at 0x01E15610&gt;
</code></pre></div></p>
<p>设计模式称之为“模式”，就是一些固定的套路。我们很容易用到其他场景上，比如前面讲的工厂模式，我们需要将工厂类定义成“单例”，只需要简单的套用即可实现：
<div class="highlight"><pre><span></span><code>#测试工厂模式和单例模式的整合使用
class CarFactory:
    __obj = None #类属性
    __init_flag = True

    def create_car(self,brand):
        if brand ==&quot;奔驰&quot;:
            return Benz()
        elif brand ==&quot;宝马&quot;:
            return BMW()
        elif brand == &quot;比亚迪&quot;:
            return BYD()
        else:
            return &quot;未知品牌，无法创建&quot;

    def __new__(cls, *args, **kwargs):
        if cls.__obj ==None:
            cls.__obj = object.__new__(cls)

        return cls.__obj

    def __init__(self):
        if CarFactory.__init_flag:
            print(&quot;init CarFactory....&quot;)
            CarFactory.__init_flag = False

class Benz:
    pass

class BMW:
    pass

class BYD:
    pass

factory = CarFactory()
c1 = factory.create_car(&quot;奔驰&quot;)
c2 = factory.create_car(&quot;比亚迪&quot;)
print(c1)
print(c2)

factory2 = CarFactory()
print(factory)
print(factory2)
</code></pre></div>
运算结果：
<div class="highlight"><pre><span></span><code>init CarFactory....
&lt;__main__.Benz object at 0x01E36E90&gt;
&lt;__main__.BYD object at 0x01E36C30&gt;
&lt;__main__.CarFactory object at 0x01E36730&gt;
&lt;__main__.CarFactory object at 0x01E36730&gt;
</code></pre></div></p>












                
              </article>
            </div>
          
          
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var labels=set.querySelector(".tabbed-labels");for(var tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script>

<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2025 ZhangBinbin/All Rights Reserved.
    </div>
  
  
</div>
      
        <div class="md-social">
  
    
    
    
    
    <a href="https://iamzhangbinbin.github.io/" target="_blank" rel="noopener" title="Wechat" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M385.2 167.6c6.4 0 12.6.3 18.8 1.1C387.4 90.3 303.3 32 207.7 32 100.5 32 13 104.8 13 197.4c0 53.4 29.3 97.5 77.9 131.6l-19.3 58.6 68-34.1c24.4 4.8 43.8 9.7 68.2 9.7 6.2 0 12.1-.3 18.3-.8-4-12.9-6.2-26.6-6.2-40.8-.1-84.9 72.9-154 165.3-154m-104.5-52.9c14.5 0 24.2 9.7 24.2 24.4 0 14.5-9.7 24.2-24.2 24.2-14.8 0-29.3-9.7-29.3-24.2.1-14.7 14.6-24.4 29.3-24.4m-136.4 48.6c-14.5 0-29.3-9.7-29.3-24.2 0-14.8 14.8-24.4 29.3-24.4 14.8 0 24.4 9.7 24.4 24.4 0 14.6-9.6 24.2-24.4 24.2M563 319.4c0-77.9-77.9-141.3-165.4-141.3-92.7 0-165.4 63.4-165.4 141.3S305 460.7 397.6 460.7c19.3 0 38.9-5.1 58.6-9.9l53.4 29.3-14.8-48.6C534 402.1 563 363.2 563 319.4m-219.1-24.5c-9.7 0-19.3-9.7-19.3-19.6 0-9.7 9.7-19.3 19.3-19.3 14.8 0 24.4 9.7 24.4 19.3 0 10-9.7 19.6-24.4 19.6m107.1 0c-9.7 0-19.3-9.7-19.3-19.6 0-9.7 9.7-19.3 19.3-19.3 14.5 0 24.4 9.7 24.4 19.3.1 10-9.9 19.6-24.4 19.6"/></svg>
    </a>
  
    
    
    
    
    <a href="https://iamzhangbinbin.github.io/" target="_blank" rel="noopener" title="telegram" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M248 8C111.033 8 0 119.033 0 256s111.033 248 248 248 248-111.033 248-248S384.967 8 248 8m114.952 168.66c-3.732 39.215-19.881 134.378-28.1 178.3-3.476 18.584-10.322 24.816-16.948 25.425-14.4 1.326-25.338-9.517-39.287-18.661-21.827-14.308-34.158-23.215-55.346-37.177-24.485-16.135-8.612-25 5.342-39.5 3.652-3.793 67.107-61.51 68.335-66.746.153-.655.3-3.1-1.154-4.384s-3.59-.849-5.135-.5q-3.283.746-104.608 69.142-14.845 10.194-26.894 9.934c-8.855-.191-25.888-5.006-38.551-9.123-15.531-5.048-27.875-7.717-26.8-16.291q.84-6.7 18.45-13.7 108.446-47.248 144.628-62.3c68.872-28.647 83.183-33.623 92.511-33.789 2.052-.034 6.639.474 9.61 2.885a10.45 10.45 0 0 1 3.53 6.716 43.8 43.8 0 0 1 .417 9.769"/></svg>
    </a>
  
    
    
    
    
      
      
    
    <a href="https://iamzhangbinbin.github.io/" target="_blank" rel="noopener" title="iamzhangbinbin.github.io" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M389.2 48h70.6L305.6 224.2 487 464H345L233.7 318.6 106.5 464H35.8l164.9-188.5L26.8 48h145.6l100.5 132.9zm-24.8 373.8h39.1L151.1 88h-42z"/></svg>
    </a>
  
    
    
    
    
      
      
    
    <a href="https://iamzhangbinbin.github.io/" target="_blank" rel="noopener" title="iamzhangbinbin.github.io" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
    </a>
  
    
    
    
    
    <a href="mailto:<z466302@126.com>" target="_blank" rel="noopener" title="" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M64 112c-8.8 0-16 7.2-16 16v22.1l172.5 141.6c20.7 17 50.4 17 71.1 0L464 150.1V128c0-8.8-7.2-16-16-16zM48 212.2V384c0 8.8 7.2 16 16 16h384c8.8 0 16-7.2 16-16V212.2L322 328.8c-38.4 31.5-93.7 31.5-132 0zM0 128c0-35.3 28.7-64 64-64h384c35.3 0 64 28.7 64 64v256c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64z"/></svg>
    </a>
  
    
    
    
    
      
      
    
    <a href="https://iamzhangbinbin.github.io/" target="_blank" rel="noopener" title="iamzhangbinbin.github.io" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M488.6 104.1c16.7 18.1 24.4 39.7 23.3 65.7v202.4c-.4 26.4-9.2 48.1-26.5 65.1-17.2 17-39.1 25.9-65.5 26.7H92.02c-26.45-.8-48.21-9.8-65.28-27.2C9.682 419.4.767 396.5 0 368.2V169.8c.767-26 9.682-47.6 26.74-65.7C43.81 87.75 65.57 78.77 92.02 78h29.38L96.05 52.19c-5.75-5.73-8.63-13-8.63-21.79 0-8.8 2.88-16.06 8.63-21.797C101.8 2.868 109.1 0 117.9 0q13.2 0 21.9 8.603L213.1 78h88l74.5-69.397C381.7 2.868 389.2 0 398 0q13.2 0 21.9 8.603c5.7 5.737 8.6 12.997 8.6 21.797 0 8.79-2.9 16.06-8.6 21.79L394.6 78h29.3c26.4.77 48 9.75 64.7 26.1m-38.8 69.7c-.4-9.6-3.7-17.4-10.7-23.5-5.2-6.1-14-9.4-22.7-9.8H96.05c-9.59.4-17.45 3.7-23.58 9.8-6.14 6.1-9.4 13.9-9.78 23.5v194.4c0 9.2 3.26 17 9.78 23.5s14.38 9.8 23.58 9.8H416.4c9.2 0 17-3.3 23.3-9.8s9.7-14.3 10.1-23.5zm-264.3 42.7c6.3 6.3 9.7 14.1 10.1 23.2V273c-.4 9.2-3.7 16.9-9.8 23.2-6.2 6.3-14 9.5-23.6 9.5s-17.5-3.2-23.6-9.5-9.4-14-9.8-23.2v-33.3c.4-9.1 3.8-16.9 10.1-23.2s13.2-9.6 23.3-10c9.2.4 17 3.7 23.3 10m191.5 0c6.3 6.3 9.7 14.1 10.1 23.2V273c-.4 9.2-3.7 16.9-9.8 23.2s-14 9.5-23.6 9.5-17.4-3.2-23.6-9.5c-7-6.3-9.4-14-9.7-23.2v-33.3c.3-9.1 3.7-16.9 10-23.2s14.1-9.6 23.3-10c9.2.4 17 3.7 23.3 10"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
      <div class="md-progress" data-md-component="progress" role="progressbar"></div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "../../..", "features": ["navigation.instant", "navigation.instant.progress", "navigation.tracking", "navigation.tabs", "navigation.sections", "navigation.expand", "navigation.prune", "navigation.indexes", "toc.integrate", "navigation.top", "search.suggest", "search.highlight", "search.share", "header.autohide", "announce.dismiss", "content.code.copy", "content.code.annotate", "content.tabs.link", "content.tooltips"], "search": "../../../assets/javascripts/workers/search.d50fe291.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.13a4f30d.min.js"></script>
      
    
  </body>
</html>